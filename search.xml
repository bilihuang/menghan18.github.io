<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue的组件通信方式]]></title>
    <url>%2Fvue-component%2F</url>
    <content type="text"><![CDATA[父子组件通信父组件向子组件传递数据这种情况最常见的方式是通过标签属性向子组件传递数据，子组件用props属性接收数据。例如父组件模板如下：12345678&lt;template&gt; &lt;div&gt; &lt;detail-banner :sightName=&quot;sightName&quot; :bannerImg=&quot;bannerImg&quot; :bannerImgs=&quot;galleryImgs&quot;&gt;&lt;/detail-banner&gt; &lt;detail-header&gt;&lt;/detail-header&gt; &lt;detail-list :list=&quot;list&quot;&gt;&lt;/detail-list&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 父组件的数据以标签属性形式传递三项数据给子组件DetailBanner，子组件接收方式如下：12345678export default &#123; name: &apos;DetailBanner&apos;, props: &#123; sightName: String, bannerImg: String, bannerImgs: Array &#125;&#125; 注意子组件props接收时可以说明该数据的类型，以达到验证的目的 子组件向父组件传递数据子组件向父组件传递数据常见的方式是子组件通过emit发送事件传递数据给父组件12345&lt;template&gt; &lt;ul class=&quot;list&quot;&gt; &lt;li class=&quot;item&quot; @click=&quot;handleLetterClick&quot;&gt;A&lt;/li&gt; &lt;/ul&gt;&lt;/template&gt; 12345methods: &#123; handleLetterClick (e) &#123; this.$emit(&apos;change&apos;, e.target.innerText) &#125;&#125; 以上代码中，子组件CityAlphabet通过emit向父组件发送change事件，将标签内的文字传递给父组件12345&lt;template&gt; &lt;div&gt; &lt;city-alphabet @change=&quot;handleLetterChange&quot;&gt;&lt;/city-alphabet&gt; &lt;/div&gt;&lt;/template&gt; 父组件在子组件相应的标签上添加事件change来接收子组件发送的数据,并在handleLetterChange方法中对数据进行处理 兄弟组件通信兄弟组件即为同一父组件下的同级子组件，这类组件通信可以通过像父子组件通信方式来实现，先子传父，再父传子，这里不再赘述。还有一种方法是通过查找父组件的子组件实现，也就是this.$parent.$children，在$children中可以通过组件名查询到组件实例，然后进行通信 跨多层次组件通信对于这种情况可以使用provide/inject假设有父组件A，一个跨多层级的子组件B12345678910111213// 父组件export default &#123; provide: &#123; data: 1 &#125;&#125;// 子组件export default &#123; inject: [&apos;data&apos;] mounted: &#123; console.log(this.data) // 1 &#125;&#125; 然而这种方式官方文档不推荐直接使用到业务代码中 任意组件任意组件的通信可以通过 Event Bus 来实现，通过在 Vue 的原型上添加一个 bus 属性，并通过该属性监听组件上值的改变。如以下代码实现兄弟组件的传值123456789101112131415161718192021222324252627282930313233&lt;div id=&apos;app&apos;&gt; &lt;child content=&apos;A&apos;&gt;&lt;/child&gt; &lt;child content=&apos;B&apos;&gt;&lt;/child&gt;&lt;/div&gt;&lt;script&gt; // 在Vue原型上添加bus属性 Vue.prototype.bus = new Vue() Vue.component(&apos;child&apos;, &#123; data: funtion() &#123; return &#123; selfContent: this.content &#125; &#125;, props: &#123; content: String &#125;, template: &apos;&lt;div @click=&quot;handleClick&quot;&gt;&#123;&#123;selfContent&#125;&#125;&lt;/div&gt;&apos; methods: &#123; handleClick: function() &#123; // 向外触发change事件 this.bus.$emit(&apos;change&apos;, this.selfContent) &#125; &#125;, mounted: function() &#123; let _this = this; // 监听change事件 this.bus.$on(&apos;change&apos;, function(msg) &#123; _this.selfContent = msg &#125;) &#125; &#125;)&lt;/script&gt; 当然除此之外我们可以通过 Vuex 来实现，Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式，这里就不详细介绍。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-router相关知识]]></title>
    <url>%2Fvue-router%2F</url>
    <content type="text"><![CDATA[解读 router/index.js12345678910111213import Vue from &apos;vue&apos; //引入Vueimport Router from &apos;vue-router&apos; //引入vue-routerimport Hello from &apos;@/components/Hello&apos; //引入根目录下的Hello.vue组件Vue.use(Router) //Vue全局使用Routerexport default new Router(&#123; routes: [ //配置路由，这里是个数组 &#123; //每一个链接都是一个对象 path: &apos;/&apos;, //链接路径 name: &apos;Hello&apos;, //路由名称， component: Hello //对应的组件模板 &#125; ]&#125;) vue-router传参一. 用name传参1.在src/router/index.js例配置name属性1234567routes: [&#123; path: &apos;/&apos;, name: &apos;Hello&apos;, component: Hello&#125;] 2.模板里(src/App.vue)用$route.name的形式接收，比如直接在模板中显示：1&lt;p&gt;&#123;&#123; $route.name&#125;&#125;&lt;/p&gt; 二. 用标签中的to传参1&lt;router-link :to=&quot;&#123;name:xxx,params:&#123;key:value&#125;&#125;&quot;&gt;valueString&lt;/router-link&gt; 这里的to前边是带冒号的，然后后边跟的是一个对象形式的字符串. name:就是在路由配置文件中起的name值。 params:就是我们要传的参数，它也是对象形式，在对象里可以传递多个值。 vue-router 利用url传递参数:冒号的形式传递参数 我们可以在理由配置文件里以:冒号的形式传递参数，这就是对参数的绑定。 1234&#123; path:&apos;/params/:newsId/:newsTitle&apos;, component:Params&#125; 在src/components目录下建立我们params.vue组件，也可以说是页面。我们在页面里输出了url传递的的新闻ID和新闻标题。 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; msg &#125;&#125;&lt;/h2&gt; &lt;p&gt;新闻ID：&#123;&#123; $route.params.newsId&#125;&#125;&lt;/p&gt; &lt;p&gt;新闻标题：&#123;&#123; $route.params.newsTitle&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;params&apos;, data () &#123; return &#123; msg: &apos;params page&apos; &#125; &#125;&#125;&lt;/script&gt; 在App.vue文件里加入我们的标签。这时候我们可以直接利用url传值了。 1&lt;router-link to=&quot;/params/198/jspang website is very good&quot;&gt;params&lt;/router-link&gt; redirect和aliasredirect基本重定向我们只要在路由配置文件中（/src/router/index.js）把原来的component换成redirect参数就可以了。我们来看一个简单的配置。1234567891011121314export default new Router(&#123; routes: [ &#123; path: &apos;/&apos;, component: Hello &#125;,&#123; path:&apos;/params/:newsId(\\d+)/:newsTitle&apos;, component:Params &#125;,&#123; path:&apos;/goback&apos;, redirect:&apos;/&apos; &#125; ]&#125;) alias别名使用 首先我们在路由配置文件里（/src/router/index.js），给上节课的Home路径起一个别名，hdy。 12345&#123; path: &apos;/hi1&apos;, component: Hi1, alias:&apos;/hdy&apos; &#125; 配置我们的，起过别名之后，可以直接使用标签里的to属性，进行重新定向。 1&lt;router-link &lt; to=&quot;/hdy&quot;&gt;jspang&lt;/router-link&gt; redirect和alias的区别 redirect：仔细观察URL，redirect是直接改变了url的值，把url变成了真实的path路径。 URL路径没有别改变，这种情况更友好，让用户知道自己访问的路径，只是改变了&lt;router-view&gt;中的内容。 路由的过渡动画&lt;transition&gt;标签想让路由有过渡动画，需要在&lt;router-view&gt;标签的外部添加&lt;transition&gt;标签，标签还需要一个name属性。123&lt;transition name=&quot;fade&quot;&gt; &lt;router-view &gt;&lt;/router-view&gt;&lt;/transition&gt; css过渡类名:组件过渡过程中，会有四个CSS类名进行切换，这四个类名与transition的name属性有关，比如name=”fade”,会有如下四个CSS类名： fade-enter:进入过渡的开始状态，元素被插入时生效，只应用一帧后立刻删除。 fade-enter-active:进入过渡的结束状态，元素被插入时就生效，在过渡过程完成后移除。 fade-leave:离开过渡的开始状态，元素被删除时触发，只应用一帧后立刻删除。 fade-leave-active:离开过渡的结束状态，元素被删除时生效，离开过渡完成后被删除。 过渡模式mode： in-out:新元素先进入过渡，完成之后当前元素过渡离开。(默认) out-in:当前元素先进行过渡离开，离开完成后新元素过渡进入。 路由属性mode history：在此模式下url没有#号，较好看 hash：默认模式，url带有模式hash值 404页面用户会经常输错页面，当用户输错页面时，我们希望给他一个友好的提示，为此美工都会设计一个漂亮的页面，这个页面就是我们常说的404页面。 路由配置1234&#123; path:&apos;*&apos;, component:Error&#125; 路由中的钩子路由配置文件中的钩子函数 我们可以直接在路由配置文件（/src/router/index.js）中写钩子函数。但是在路由文件中我们只能写一个beforeEnter,就是在进入此路由配置时。123456789&#123; path:&apos;/params/:newsId(\\d+)/:newsTitle&apos;, component:Params, beforeEnter:(to,from,next)=&gt;&#123; console.log(&apos;我进入了params模板&apos;); console.log(to); console.log(from); next();&#125;, 三个参数： to：路由将要跳转的路径信息，信息是包含在对象里边的。 from：路径跳转前的路径信息，也是一个对象的形式。 next：路由的控制参数，常用的有next(true)和next(false)。 写在模板中的钩子函数在模板中就可以有两个钩子函数可以使用： beforeRouteEnter：在路由进入前的钩子函数。 beforeRouteLeave：在路由离开前的钩子函数。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue的基础知识点]]></title>
    <url>%2Fvue-basis%2F</url>
    <content type="text"><![CDATA[一、全局APIVue.directive自定义指令 自定义指令传递的三个参数 el: 指令所绑定的元素，可以用来直接操作DOM。 binding: 一个对象，包含指令的很多信息。 vnode: Vue编译生成的虚拟节点。 自定义指令的生命周期自定义指令有五个生命周期（也叫钩子函数），分别是bind, inserted, update, componentUpdated, unbind bind:只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个绑定时执行一次的初始化动作。 inserted:被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于document中）。 update:被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。 componentUpdated:被绑定元素所在模板完成一次更新周期时调用。 unbind:只调用一次，指令与元素解绑时调用。 Vue-setVue.set 的作用就是在构造器外部操作构造器内部的数据、属性或者方法。 为什么要有Vue.set的存在? 由于Javascript的限制，Vue不能自动检测以下变动的数组。 当你利用索引直接设置一个项时，vue不会为我们自动更新。 当你修改数组的长度时，vue不会为我们自动更新。 Vue的生命周期 钩子函数123456789101112131415161718192021222324252627282930beforeCreate:function()&#123; console.log(&apos;1-beforeCreate 初始化之后&apos;);&#125;,created:function()&#123; console.log(&apos;2-created 创建完成&apos;);&#125;,beforeMount:function()&#123; console.log(&apos;3-beforeMount 挂载之前&apos;);&#125;,mounted:function()&#123; console.log(&apos;4-mounted 被创建&apos;);&#125;,beforeUpdate:function()&#123; console.log(&apos;5-beforeUpdate 数据更新前&apos;);&#125;,updated:function()&#123; console.log(&apos;6-updated 被更新后&apos;);&#125;,activated:function()&#123; console.log(&apos;7-activated&apos;);&#125;,deactivated:function()&#123; console.log(&apos;8-deactivated&apos;);&#125;,beforeDestroy:function()&#123; console.log(&apos;9-beforeDestroy 销毁之前&apos;);&#125;,destroyed:function()&#123; console.log(&apos;10-destroyed 销毁之后&apos;)&#125; Template模板 直接写在选项里，适合较短的html代码 写在template标签里，适合长的html代码 写在script标签里，适合外部引入模板文件 组件Component组件就是自定义的标签 全局化注册组件全局化就是在构造器的外部用Vue.component来注册 局部注册组件局部注册组件局部注册组件和全局注册组件是相对应的，局部注册的组件只能在组件注册的作用域里进行使用，其他作用域使用无效。 组件和指令的区别组件注册的是一个标签，而指令注册的是已有标签里的一个属性。在实际开发中我们还是用组件比较多，指令用的比较少。因为指令看起来封装的没那么好，这只是个人观点。 Component 父子组件关系在实际开发中我们经常会遇到在一个自定义组件中要使用其他自定义组件，这就需要一个父子组件关系。 Component 标签标签是Vue框架自定义的标签，它的用途就是可以动态绑定我们的组件，根据数据的不同更换不同的组件。 二、实例实例方法 $mount 方法用来挂在扩展 $destroy() 卸载方法 $forceUpdate() 更新方法 $nextTick() 数据修改方法当Vue构造器里的data值被修改完成后会调用这个方法 实例事件 $on 在构造器外部添加事件$on接收两个参数，第一个参数是调用时的事件名称，第二个参数是一个匿名方法。 1234app.$on(&apos;reduce&apos;,function()&#123; console.log(&apos;执行了reduce()&apos;); this.num--;&#125;); $once 执行一次的事件 $off 关闭事件 1234//关闭事件function off()&#123; app.$off(&apos;reduce&apos;);&#125; slotslot是标签的内容扩展，也就是说你用slot就可以在自定义组件时传递给组件内容，组件接收内容并输出。 三、选项相关computed Option 计算选项computed 的作用主要是对原数据进行改造输出。改造输出：包括格式的编辑，大小写转换，顺序重排，添加符号……。 Methods Option 方法选项 methods中参数的传递使用方法和正常的javascript传递参数的方法一样，分为两部： 在methods的方法中进行声明，比如我们给add方法加上一个num参数，就要写出add:function(num){} 调用方法时直接传递，比如我们要传递2这个参数，我们在button上就直接可以写。@click=”add(2)”&gt;&lt;/button&gt; methods中的$event参数传递的$event参数都是关于你点击鼠标的一些事件和属性。 native 给组件绑定构造器里的原生事件在实际开发中经常需要把某个按钮封装成组件，然后反复使用，如何让组件调用构造器里的方法，而不是组件里的方法。就需要用到我们的.native修饰器了&lt;p&gt;&lt;btn @click.native=&quot;add(3)&quot;&gt;&lt;/btn&gt;&lt;/p&gt; 作用域外部调用构造器里的方法&lt;button onclick=&quot;app.add(4)&quot; &gt;&lt;/button&gt;不常用，不提倡用 Mixins 混入选项操作 Mixins一般有两种用途： 在你已经写好了构造器后，需要增加方法或者临时的活动时使用的方法，这时用混入会减少源代码的污染。 很多地方都会用到的公用方法，用混入的方法可以减少代码量，实现代码重用。 mixins的调用顺序全局-&gt;混入-&gt;构造器里PS：当混入方法和构造器的方法重名时，混入的方法无法展现，也就是不起作用。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6解构赋值与函数相关知识点]]></title>
    <url>%2Fes6-function%2F</url>
    <content type="text"><![CDATA[一、箭头函数注意点 箭头函数有几个使用注意点： （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 this对象的指向一般是可变的，但是在箭头函数中，它是固定的。12345678910function foo() &#123; setTimeout(() =&gt; &#123; console.log(&apos;id:&apos;, this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// id: 42 上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。 箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。1234567891011121314151617function Timer() &#123; this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() =&gt; this.s1++, 1000); // 普通函数 setInterval(function () &#123; this.s2++; &#125;, 1000);&#125;var timer = new Timer();setTimeout(() =&gt; console.log(&apos;s1: &apos;, timer.s1), 3100);setTimeout(() =&gt; console.log(&apos;s2: &apos;, timer.s2), 3100);// s1: 3// s2: 0 上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，timer.s1被更新了 3 次，而timer.s2一次都没更新。 箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面。123456789101112var handler = &#123; id: &apos;123456&apos;, init: function() &#123; document.addEventListener(&apos;click&apos;, event =&gt; this.doSomething(event.type), false); &#125;, doSomething: function(type) &#123; console.log(&apos;Handling &apos; + type + &apos; for &apos; + this.id); &#125;&#125;; 上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。 所以，箭头函数转成 ES5 的代码如下。123456789101112131415// ES6function foo() &#123; setTimeout(() =&gt; &#123; console.log(&apos;id:&apos;, this.id); &#125;, 100);&#125;// ES5function foo() &#123; var _this = this; setTimeout(function () &#123; console.log(&apos;id:&apos;, _this.id); &#125;, 100);&#125; 上面代码中，可以看出箭头函数里面根本没有自己的this，而是引用外层的this。 请问下面的代码之中有几个this？123456789101112131415function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log(&apos;id:&apos;, this.id); &#125;; &#125;; &#125;;&#125;var f = foo.call(&#123;id: 1&#125;);var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1var t2 = f().call(&#123;id: 3&#125;)(); // id: 1var t3 = f()().call(&#123;id: 4&#125;); // id: 1 上面代码之中，只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。 除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。12345678function foo() &#123; setTimeout(() =&gt; &#123; console.log(&apos;args:&apos;, arguments); &#125;, 100);&#125;foo(2, 4, 6, 8)// args: [2, 4, 6, 8] 上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。 另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。123456(function() &#123; return [ (() =&gt; this.x).bind(&#123; x: &apos;inner&apos; &#125;)() ];&#125;).call(&#123; x: &apos;outer&apos; &#125;);// [&apos;outer&apos;] 上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。 长期以来，JavaScript 语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。箭头函数”绑定”this，很大程度上解决了这个困扰。 二、双冒号运算符箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以现在有一个提案，提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。 函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。123456789101112foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments);const hasOwnProperty = Object.prototype.hasOwnProperty;function hasOwn(obj, key) &#123; return obj::hasOwnProperty(key);&#125; 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。1234567var method = obj::obj.foo;// 等同于var method = ::obj.foo;let log = ::console.log;// 等同于var log = console.log.bind(console); 如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法。123456import &#123; map, takeWhile, forEach &#125; from &quot;iterlib&quot;;getPlayers()::map(x =&gt; x.character())::takeWhile(x =&gt; x.strength &gt; 100)::forEach(x =&gt; console.log(x)); 三、解构赋值解构赋值默认值与函数参数默认值123456789// 写法一function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;// 写法二function m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125; 写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。123456789101112131415161718// 函数没有参数的情况m1() // [0, 0]m2() // [0, 0]// x 和 y 都有值的情况m1(&#123;x: 3, y: 8&#125;) // [3, 8]m2(&#123;x: 3, y: 8&#125;) // [3, 8]// x 有值，y 无值的情况m1(&#123;x: 3&#125;) // [3, 0]m2(&#123;x: 3&#125;) // [3, undefined]// x 和 y 都无值的情况m1(&#123;&#125;) // [0, 0];m2(&#123;&#125;) // [undefined, undefined]m1(&#123;z: 3&#125;) // [0, 0]m2(&#123;z: 3&#125;) // [undefined, undefined] 函数的length属性指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。123(function (a) &#123;&#125;).length // 1(function (a = 5) &#123;&#125;).length // 0(function (a, b, c = 5) &#123;&#125;).length // 2 上面代码中，length属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3 个参数，其中有一个参数c指定了默认值，因此length属性等于3减去1，最后得到2。 这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入length属性。1(function(...args) &#123;&#125;).length // 0 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。12(function (a = 0, b, c) &#123;&#125;).length // 0(function (a, b = 1, c) &#123;&#125;).length // 1 本文参考自阮一峰大神的《ES6标准入门》原文链接：http://es6.ruanyifeng.com/]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中的数组相关知识点]]></title>
    <url>%2Fjs-array%2F</url>
    <content type="text"><![CDATA[1.数组的每一项可以用来保存任何类型的数据 2.可以通过length属性在数组末尾移除项或向数组添加新项123var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; //creates an array with three stringscolors.length = 2;alert(colors[2]); //undefined 123var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; //creates an array with three stringscolors.length = 4;alert(colors[3]); //undefined 3.alert()方法要接收字符串参数时会在后台调用toString()方法，都是创建一个数组值的以逗号分隔的字符串 4.join()方法可以使用不同的分隔符来构建字符串123var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];alert(colors.join(&quot;,&quot;)); //red,green,bluealert(colors.join(&quot;||&quot;)); //red||green||blue 5.栈和队列 push()返回添加后的数组长度，而pop()返回移除的项,二者实现类似栈行为 shift()移除数组中第一个项并返回该项，数组长度减一，和push()结合模拟队列 unshift()在数组前端添加任意个项并返回新数组长度，与pop()结合从相反方向模拟队列 6.重排序方法 reverse()反转数组项顺序 sort()调用每个数组项的toString()，比较得到的字符串确定排序，即是数组项是数值 7.操作方法concat()基于当前数组中的所有项创建一个新数组1234var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];var colors2 = colors.concat(&quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]);alert(colors); //red,green,blue alert(colors2); //red,green,blue,yellow,black,brown slice()基于当前数组的一或多项创建一个新数组 12345var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;];var colors2 = colors.slice(1);var colors3 = colors.slice(1,4);alert(colors2); //green,blue,yellow,purplealert(colors3); //green,blue,yellow splice() 删除：可以删除任意数量的项，参数为要删除的第一项位置和要删除的项数 1234var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];var removed = colors.splice(0,1); //remove the first itemalert(colors); //green,bluealert(removed); //red - one item array 插入：向指定位置插入任意数量的项，需提供3个参数：起始位置、0（要删除的项数）和要插入的项。例如，splice(2,0,”red”,”green”)会从当前数组的位置2开始插入字符串red和green 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项。3个参数：起始位置、要删除的项数和要插入的任意数量的项。例如，splice(2,1,”red”,”green”)会删除当前数组位置2的项，然后再从位置2开始插入red和green 8.位置方法indexOf()和lastIndexOf()都有2个参数：要查找的项和（可选）表示查找起点位置的索引，返回查找项的位置，没找到返回-1。indexOf()正向查找，lastIndexOf()反向 9.迭代方法2个参数：要在每一项上运行的函数和（可选）运行该函数的作用域对象；其中的函数有3个参数：数组项的值、该项在数组中的位置和数组对象本身 every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组 forEach()：对数组中的每一项运行给定函数，无返回值 map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组 some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true 10.归并方法2个参数：一个在每一项上调用的函数和（可选）作为归并基础的初始值；其中的函数有4个参数：前一个值、当前值、项的索引和数组对象，函数的返回值作为第一参数传给下一项，第一个参数时数组的第一项，第二个参数时数组的第二项 reduce()从数组第一项开始逐个遍历 reduceRight()从数组最后一项开始，反向遍历]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2FgitCommand%2F</url>
    <content type="text"><![CDATA[一、新建代码库123git init 在当前目录新建一个Git代码库 git init [project-name] 新建一个目录，将其初始化为Git代码库 git clone [url] 下载一个项目和它的整个代码历史 二、配置1234git config --list 显示当前的Git配置git config -e [--global] 编辑Git配置文件git config [--global] user.name &quot;[name]&quot; git config [--global] user.email &quot;[email address]&quot; 设置提交代码时的用户信息 三、添加/删除/修改文件123456789git status 查看状态git diff 查看变更内容git add [file1] [file2] ... 添加指定文件到暂存区git add [dir] 添加指定目录到暂存区，包括子目录git add . 添加当前目录的所有文件到暂存区git add -p 添加每个变化前，都会要求确认 对于同一个文件的多处变化，可以实现分次提交 git rm [file1] [file2] ...删除工作区文件，并且将这次删除放入暂存区git rm --cached [file] 停止追踪指定文件，但该文件会保留在工作区git mv [file-original] [file-renamed] 改名文件，并且将这个改名放入暂存区 四、代码提交123456git commit -m [message] 提交暂存区到仓库区git commit [file1] [file2] ... -m [message]提交暂存区的指定文件到仓库区git commit -a 提交工作区自上次commit之后的变化，直接到仓库区git commit -v提交时显示所有diff信息git commit --amend -m [message] 使用一次新的commit，替代上一次提交 如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend [file1] [file2] ... 重做上一次commit，并包括指定文件的新变化 五、分支123456789101112131415git branch 显示所有本地分支git branch -r 列出所有远程分支git branch -a 列出所有本地分支和远程分支git branch [branch-name] 新建一个分支，但依然停留在当前分支git branch --track [branch] [remote-branch] 新建一个分支，与指定的远程分支建立追踪关系git branch -d [branch-name] 删除分支git push origin --detele [branch-name] git branch -dr [remote/branch] 删除远程分支git checkout -b [branch] 新建一个分支，并切换到该分支git checkout [branch-name] 切换到指定分支，并更新工作区git checkout - 切换到上一个分支git branch --set -upstream [branch] [remote-branch] 建立追踪关系，在现有分支与指定的远程分支之间git merge [branch] 合并指定分支到当前分支git rebase &lt;branch&gt; 衍合指定分支到当前分支git cherry-pick [commit] 选择一个commit，合并到当前分支 六、标签12345678git tag 列出所有本地标签git tag &lt;tag-name&gt; 基于最新的提交创建标签git tag -d &lt;tag-name&gt; 删除指定标签git push origin :refs/tags/[tag-name] 删除远程标签git show [tag] 查看标签信息git push [remote] [tag] 提交指定标签git push [remote] --tags 提交所有标签git checkout -b [branch] [tag] 新建一个分支，指向某个标签 七、查看信息123456789101112131415161718192021git status 显示有变更的文件git log 显示当前分支的版本历史git log --stat 显示提交历史，以及每次提交发生变更的文件git log -S [keyword] 根据关键词搜索提交历史git log [tag] HEAD --pretty=format:%s 显示某个提交之后的所有变动git log [tag] HEAD --grep featuregit log --follow [file]git whatchanged [file] 显示某个文件的版本历史，包括文件改名git log -p [file] 显示指定文件相关的每一次diffgit log -5 --pretty --online 显示过去5次提交git shortlog -sn 显示所有提交过的用户，按提交次数排序git blame [file] 显示指定文件是何人何时修改信息git diff 显示暂存区与工作区的差异git diff --cached [file] 显示暂存区和上一个提交的差异git diff HEAD 显示工作区与当前分支最新调教之间的差异git diff [first-branch]...[second-branch] 显示两次提交之间的差异git diff --short stat &quot;@&#123;0 day ago&#125;&quot; 显示今天你写了多少行代码git show [commit] 显示某次提交的元数据和内容变化git show --name-only [commit] 显示某次提交发生变化的文件gitshow [commit]:[filename] 显示某次提交时，某个文件的内容git reflog 显示当前分支的最近几次提交 八、远程操作12345678910git fetch [remote] 下载远程仓库的所有变动git pull [remote] [branch] 取回远程参股的变化，并与本地分支合并git remote -v 显示所有远程仓库git remote show [remote] 显示某个远程仓库的信息git remote add [shortname] [url] 增加一个新的远程仓库git push [remote] [branch] 上传本地指定分支到远程仓库git push [remote] --force 强制推送当前分支到远程仓库git push [remote] --all 推动所有分支到远程仓库git push &lt;remote&gt; 删除远程分支或标签git push --tags 上传所有标签 九、撤销123456789101112131415git reset --hard HEAD 撤销工作目录中所有未提交文件的修改内容git checkout HEAD &lt;file&gt; 撤销指定的未提交文件的修改内容git revert &lt;commit&gt; 撤销指定的提交git log --before=&quot;1 days&quot; 退回到之前1天的版本git checkout [file] 恢复暂存区的指定文件到工作区git checkout [commit] [file] 恢复某个提交的指定文件到暂存区和工作区git checkout . 恢复暂存区的所有文件到工作区git reset [file] 重置暂存区的指定文件，遇上一次提交保持一致，但工作区不变git reset --hard 重置暂存区与工作区，与上次提交保持一致git reset [commit] 重置当前分支的指针为指定提交，同时重置暂存区，但工作区不变git reset --hard [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --keep [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变git revert [commit] 新建一个commit，用来撤销指定commit，后者的所有变化豆浆杯前者抵消，并且应用到当前分支git stashgit stash pop 暂时将未提交的变化移除，稍后再移入]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
