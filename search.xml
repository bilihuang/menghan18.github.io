<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[npm scripts使用指南]]></title>
    <url>%2Fnpmscripts%2F</url>
    <content type="text"><![CDATA[最近做了一套笔试题，上来第一二道题都是关于npm脚本的问题，以前没深入学习过，特此补充一下这方面的知识。 一、什么是npm脚本(npm scripts)？用过npm的人都知道 package.json 文件，它定义了一个项目所需要的各种模块，以及项目的配置信息。而npm允许在 package.json 文件里，使用 scripts 定义的脚本命令，这些脚本就称为npm脚本。123456&#123; // ... &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;node build.js&quot; &#125;&#125; 上面代码是 package.json 文件的一个片段，里面的 scripts 字段是一个对象。它的每一个属性，对应一段脚本。比如，build 命令对应的脚本是 node build.js 。 命令行下使用 npm run 命令，就可以执行这段脚本。123$ npm run build# 等同于执行$ node build.js npm脚本的优点很多，如： 项目的相关脚本，可以集中在一个地方。 不同项目的脚本命令，只要功能相同，就可以有同样的对外接口。用户不需要知道怎么测试你的项目，只要运行 npm run test 即可。 可以利用 npm 提供的很多辅助功能。 查看当前项目的所有 npm 脚本命令，可以使用不带任何参数的 npm run 命令。1$ npm run 二、原理每当执行 npm run ，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。 比较特别的是，npm run 新建的这个 Shell，会将当前目录的 node_modules/.bin 子目录加入 PATH 变量，执行结束后，再将 PATH 变量恢复原样。 这意味着，当前目录的 node_modules/.bin 子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。比如，当前项目的依赖里面有 Mocha，只要直接写 mocha test 就可以了。1&quot;test&quot;: &quot;mocha test&quot; 而不用写成下面这样。1&quot;test&quot;: &quot;./node_modules/.bin/mocha test&quot; 由于 npm 脚本的唯一要求就是可以在 Shell 执行，因此它不一定是 Node 脚本，任何可执行文件都可以写在里面。 npm 脚本的退出码，也遵守 Shell 脚本规则。如果退出码不是0，npm 就认为这个脚本执行失败。 三、通配符由于 npm 脚本就是 Shell 脚本，因此可以使用 Shell 通配符。 12&quot;lint&quot;: &quot;jshint *.js&quot;&quot;lint&quot;: &quot;jshint **/*.js&quot; 上面代码中，* 表示任意文件名，** 表示任意一层子目录。 如果要将通配符传入原始命令，防止被 Shell 转义，要将星号转义。 1&quot;test&quot;: &quot;tap test/\*.js&quot; 四、传参我们可以向npm脚本传入参数，但要使用 -- 标明 1&quot;lint&quot;: &quot;jshint **.js&quot; 向上面的 npm run lint 命令传入参数，必须写成下面这样。 1$ npm run lint -- --reporter checkstyle &gt; checkstyle.xml 也可以在 package.json 里面再封装一个命令。 12&quot;lint&quot;: &quot;jshint **.js&quot;,&quot;lint:checkstyle&quot;: &quot;npm run lint -- --reporter checkstyle &gt; checkstyle.xml&quot; 五、执行顺序如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。 如果是并行执行（即同时的平行执行），可以使用&amp;符号。 1$ npm run script1.js &amp; npm run script2.js 如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用&amp;&amp;符号。 1$ npm run script1.js &amp;&amp; npm run script2.js 这两个符号是 Bash 的功能。此外，还可以使用 node 的任务管理模块：script-runner、npm-run-all、redrun。 六、默认值一般来说，npm 脚本由用户提供。但是，npm 对两个脚本提供了默认值。也就是说，这两个脚本不用定义，就可以直接使用。 12&quot;start&quot;: &quot;node server.js&quot;，&quot;install&quot;: &quot;node-gyp rebuild&quot; 上面代码中，npm run start 的默认值是 node server.js，前提是项目根目录下有 server.js 这个脚本；npm run install 的默认值是 node-gyp rebuild，前提是项目根目录下有 binding.gyp 文件。 七、钩子npm 脚本有 pre 和 post 两个钩子。举例来说，build 脚本命令的钩子就是 prebuild 和 postbuild。 123&quot;prebuild&quot;: &quot;echo I run before the build script&quot;,&quot;build&quot;: &quot;cross-env NODE_ENV=production webpack&quot;,&quot;postbuild&quot;: &quot;echo I run after the build script&quot; 用户执行 npm run build 的时候，会自动按照下面的顺序执行。 1npm run prebuild &amp;&amp; npm run build &amp;&amp; npm run postbuild 因此，可以在这两个钩子里面，完成一些准备工作和清理工作。下面是一个例子。 123&quot;clean&quot;: &quot;rimraf ./dist &amp;&amp; mkdir dist&quot;,&quot;prebuild&quot;: &quot;npm run clean&quot;,&quot;build&quot;: &quot;cross-env NODE_ENV=production webpack&quot; npm 默认提供下面这些钩子。 prepublish，postpublish preinstall，postinstall preuninstall，postuninstall preversion，postversion pretest，posttest prestop，poststop prestart，poststart prerestart，postrestart 自定义的脚本命令也可以加上 pre 和 post 钩子。比如，myscript 这个脚本命令，也有 premyscript 和 postmyscript 钩子。不过，双重的 pre 和 post 无效，比如 prepretest 和 postposttest 是无效的。 npm 提供一个 npm_lifecycle_event 变量，返回当前正在运行的脚本名称，比如 pretest 、test、posttest 等等。所以，可以利用这个变量，在同一个脚本文件里面，为不同的 npm scripts 命令编写代码。请看下面的例子。 12345678910111213const TARGET = process.env.npm_lifecycle_event;if (TARGET === &apos;test&apos;) &#123; console.log(`Running the test task!`);&#125;if (TARGET === &apos;pretest&apos;) &#123; console.log(`Running the pretest task!`);&#125;if (TARGET === &apos;posttest&apos;) &#123; console.log(`Running the posttest task!`);&#125; 注意: prepublish 这个钩子不仅会在 npm publish 命令之前运行，还会在 npm install （不带任何参数）命令之前运行。这种行为很容易让用户感到困惑，所以 npm 4 引入了一个新的钩子 prepare，行为等同于 prepublish ，而从 npm 5 开始，prepublish 将只在 npm publish 命令之前运行。 八、简写形式四个常用的 npm 脚本有简写形式。 npm start 是 npm run start 的简写 npm stop 是 npm run stop 的简写 npm test 是 npm run test 的简写 npm restart 是 npm run stop &amp;&amp; npm run restart &amp;&amp; npm run start 的简写 npm start、npm stop 和 npm test 都比较好理解，而 npm restart 是一个复合命令，实际上会执行三个脚本命令：stop 、restart、start。具体的执行顺序如下: prerestart prestop stop poststop restart prestart start poststart postrestart 九、变量npm 脚本有一个非常强大的功能，就是可以使用 npm 的内部变量。首先，通过 npm_package_ 前缀，npm 脚本可以拿到 package.json 里面的字段。比如，下面是一个 package.json。 1234567&#123; &quot;name&quot;: &quot;foo&quot;, &quot;version&quot;: &quot;1.2.5&quot;, &quot;scripts&quot;: &#123; &quot;view&quot;: &quot;node view.js&quot; &#125;&#125; 那么，变量 npm_package_name 返回 foo，变量 npm_package_version 返回1.2.5。 123// view.jsconsole.log(process.env.npm_package_name); // fooconsole.log(process.env.npm_package_version); // 1.2.5 上面代码中，我们通过环境变量 process.env 对象，拿到 package.json 的字段值。如果是 Bash 脚本，可以用 $npm_package_name 和 $npm_package_version 取到这两个值。 npm_package_ 前缀也支持嵌套的 package.json 字段。 1234567&quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;xxx&quot;&#125;,scripts: &#123; &quot;view&quot;: &quot;echo $npm_package_repository_type&quot;&#125; 上面代码中，repository 字段的 type 属性，可以通过 npm_package_repository_type 取到。 下面是另外一个例子。 123&quot;scripts&quot;: &#123; &quot;install&quot;: &quot;foo.js&quot;&#125; 上面代码中，npm_package_scripts_install 变量的值等于 foo.js。 然后，npm 脚本还可以通过 npm_config_ 前缀，拿到 npm 的配置变量，即 npm config get xxx 命令返回的值。比如，当前模块的发行标签，可以通过 npm_config_tag 取到。 1&quot;view&quot;: &quot;echo $npm_config_tag&quot; 注意:package.json 里面的 config 对象，可以被环境变量覆盖。 12345&#123; &quot;name&quot; : &quot;foo&quot;, &quot;config&quot; : &#123; &quot;port&quot; : &quot;8080&quot; &#125;, &quot;scripts&quot; : &#123; &quot;start&quot; : &quot;node server.js&quot; &#125;&#125; 上面代码中，npm_package_config_port 变量返回的是8080。这个值可以用下面的方法覆盖。 1$ npm config set foo:port 80 最后，env 命令可以列出所有环境变量。 1&quot;env&quot;: &quot;env&quot; 十、常用脚本示例1234567891011121314151617181920212223242526// 删除目录&quot;clean&quot;: &quot;rimraf dist/*&quot;,// 本地搭建一个 HTTP 服务&quot;serve&quot;: &quot;http-server -p 9090 dist/&quot;,// 打开浏览器&quot;open:dev&quot;: &quot;opener http://localhost:9090&quot;,// 实时刷新 &quot;livereload&quot;: &quot;live-reload --port 9091 dist/&quot;,// 构建 HTML 文件&quot;build:html&quot;: &quot;jade index.jade &gt; dist/index.html&quot;,// 只要 CSS 文件有变动，就重新执行构建&quot;watch:css&quot;: &quot;watch &apos;npm run build:css&apos; assets/styles/&quot;,// 只要 HTML 文件有变动，就重新执行构建&quot;watch:html&quot;: &quot;watch &apos;npm run build:html&apos; assets/html&quot;,// 部署到 Amazon S3&quot;deploy:prod&quot;: &quot;s3-cli sync ./dist/ s3://example-com/prod-site/&quot;,// 构建 favicon&quot;build:favicon&quot;: &quot;node scripts/favicon.js&quot;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的this和call、apply、bind]]></title>
    <url>%2Fjs-this%2F</url>
    <content type="text"><![CDATA[this是什么在JavaScript中，this是指函数作为方法被调用时所属的对象。我们可以看一下代码中函数的几种调用场景12345678910111213141516var a = 1function foo() &#123; console.log(this.a)&#125;// 全局下直接调用foo()const obj = &#123; a: 2, foo: foo&#125;// 作为对象方法调用obj.foo()// 用new操作符创建新实例const b = new foo() 在浏览器中，全局对象是 window，对于全局环境下直接调用 foo，this 一定是 window 作为对象方法调用时，谁调用了该函数，this 便指向谁，所以对于 obj.foo() 来说，函数中的 this 就是 obj 对象 对于 new 方式，this被永远绑定在 c 上，不能被任何方式改变 对于箭头函数，其本身并没有 this，箭头函数中的 this 只取决于包裹箭头函数的第一个普通函数的 this，并且箭头函数不能使用 apply、call、bind 函数来改变 this 的指向 当多种规则出现时，我们可以根据优先级来判断 this 的指向。首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。 apply、call和bind函数 call() 和 apply 两个方法作用相同，区别仅在于接受的参数的方式不同 function.apply(this.obj, args) 第二个参数 args 为数组或arguments对象 function.call(this.obj, args...) 第二个参数开始可接收任意多个参数二者第一个参数均为关键字 this 的值，参数为空时默认使用全局对象，浏览器中即为 window，最后都返回函数 function 的返回值。 bind() 与前两者不同，它的函数式为 function.bind(o, args...)，其中 o 为要绑定到函数上的对象，args... 为要绑定到函数上的零个或多个参数值，即可不带参数，最后返回一个作为对象 o 的方法来调用的新函数 对一个函数进行多次 bind ，函数的 this 永远由第一次决定，如以下代码12345678910111213let a = &#123;&#125;let fn = function () &#123; console.log(this)&#125;fn.bind().bind(a)() // window// fn.bind().bind(a) 等于let fn2 = function fn1() &#123; return function() &#123; return fn.apply() &#125;.apply(a)&#125;fn2() apply、call和bind的实现call 的实现:1234567891011Function.prototype.myCall = function(context) &#123; if (typeof this !== &apos;function&apos;) &#123; throw new TypeError(&apos;Error&apos;) &#125; context = context || window context.fn = this const args = [...arguments].slice(1) const result = context.fn(...args) delete context.fn return result&#125; 对实现的分析： 首先 context 为可选参数，如果不传的话默认上下文为 window 接下来给 context 创建一个 fn 属性，并将值设置为需要调用的函数 因为 call 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来 然后调用函数并将对象上的函数删除 apply 的实现:12345678910111213141516Function.prototype.myApply = function(context) &#123; if (typeof this !== &apos;function&apos;) &#123; throw new TypeError(&apos;Error&apos;) &#125; context = context || window context.fn = this let result // 处理参数和 call 有区别 if (arguments[1]) &#123; result = context.fn(...arguments[1]) &#125; else &#123; result = context.fn() &#125; delete context.fn return result&#125; 与 call 不同的是对参数的处理 bind 的实现:123456789101112131415Function.prototype.myBind = function (context) &#123; if (typeof this !== &apos;function&apos;) &#123; throw new TypeError(&apos;Error&apos;) &#125; const _this = this const args = [...arguments].slice(1) // 返回一个函数 return function F() &#123; // 因为返回了一个函数，我们可以 new F()，所以需要判断 if (this instanceof F) &#123; return new _this(...args, ...arguments) &#125; return _this.apply(context, args.concat(...arguments)) &#125;&#125; 对实现的分析: bind 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 new 的方式，我们先来说直接调用的方式 对于直接调用来说，这里选择了 apply 的方式实现，但是对于参数需要注意以下情况：因为 bind 可以实现类似这样的代码 f.bind(obj, 1)(2)，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 args.concat(...arguments) 最后来说通过 new 的方式，对于 new 的情况来说，不会被任何方式改变 this，所以对于这种情况我们需要忽略传入的 this new在调用 new 的过程中会发生以上四件事情： 新生成了一个对象 链接到原型 绑定 this 返回新对象new 的实现:1234567function create() &#123; let obj = &#123;&#125; let Con = [].shift.call(arguments) obj.__proto__ = Con.prototype let result = Con.apply(obj, arguments) return result instanceof Object ? result : obj&#125; 对实现的分析: 创建一个空对象 获取构造函数 设置空对象的原型 绑定 this 并执行构造函数 确保返回值为对象 对于对象来说，实际上都是通过 new 产生的，无论是 function Foo() 还是 let a = { b : 1 } 。 对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为使用 new Object() 的方式创建对象需要通过作用域链一层层找到 Object，但是使用字面量的方式就没这个问题。 12345function Foo() &#123;&#125;// function 就是个语法糖// 内部等同于 new Function()let a = &#123; b: 1 &#125;// 这个字面量内部也是使用了 new Object() 参考文献：《JavaScript高级程序设计》、掘金小册《前端面试之道》]]></content>
      <categories>
        <category>JavaScript学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue的组件通信方式]]></title>
    <url>%2Fvue-component%2F</url>
    <content type="text"><![CDATA[父子组件通信父组件向子组件传递数据这种情况最常见的方式是通过标签属性向子组件传递数据，子组件用props属性接收数据。例如父组件模板如下：12345678&lt;template&gt; &lt;div&gt; &lt;detail-banner :sightName=&quot;sightName&quot; :bannerImg=&quot;bannerImg&quot; :bannerImgs=&quot;galleryImgs&quot;&gt;&lt;/detail-banner&gt; &lt;detail-header&gt;&lt;/detail-header&gt; &lt;detail-list :list=&quot;list&quot;&gt;&lt;/detail-list&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 父组件的数据以标签属性形式传递三项数据给子组件DetailBanner，子组件接收方式如下：12345678export default &#123; name: &apos;DetailBanner&apos;, props: &#123; sightName: String, bannerImg: String, bannerImgs: Array &#125;&#125; 注意子组件props接收时可以说明该数据的类型，以达到验证的目的 子组件向父组件传递数据子组件向父组件传递数据常见的方式是子组件通过emit发送事件传递数据给父组件12345&lt;template&gt; &lt;ul class=&quot;list&quot;&gt; &lt;li class=&quot;item&quot; @click=&quot;handleLetterClick&quot;&gt;A&lt;/li&gt; &lt;/ul&gt;&lt;/template&gt; 12345methods: &#123; handleLetterClick (e) &#123; this.$emit(&apos;change&apos;, e.target.innerText) &#125;&#125; 以上代码中，子组件CityAlphabet通过emit向父组件发送change事件，将标签内的文字传递给父组件12345&lt;template&gt; &lt;div&gt; &lt;city-alphabet @change=&quot;handleLetterChange&quot;&gt;&lt;/city-alphabet&gt; &lt;/div&gt;&lt;/template&gt; 父组件在子组件相应的标签上添加事件change来接收子组件发送的数据,并在handleLetterChange方法中对数据进行处理 兄弟组件通信兄弟组件即为同一父组件下的同级子组件，这类组件通信可以通过像父子组件通信方式来实现，先子传父，再父传子，这里不再赘述。还有一种方法是通过查找父组件的子组件实现，也就是this.$parent.$children，在$children中可以通过组件名查询到组件实例，然后进行通信 跨多层次组件通信对于这种情况可以使用provide/inject假设有父组件A，一个跨多层级的子组件B12345678910111213// 父组件export default &#123; provide: &#123; data: 1 &#125;&#125;// 子组件export default &#123; inject: [&apos;data&apos;] mounted: &#123; console.log(this.data) // 1 &#125;&#125; 然而这种方式官方文档不推荐直接使用到业务代码中 任意组件任意组件的通信可以通过 Event Bus 来实现，通过在 Vue 的原型上添加一个 bus 属性，并通过该属性监听组件上值的改变。如以下代码实现兄弟组件的传值123456789101112131415161718192021222324252627282930313233&lt;div id=&apos;app&apos;&gt; &lt;child content=&apos;A&apos;&gt;&lt;/child&gt; &lt;child content=&apos;B&apos;&gt;&lt;/child&gt;&lt;/div&gt;&lt;script&gt; // 在Vue原型上添加bus属性 Vue.prototype.bus = new Vue() Vue.component(&apos;child&apos;, &#123; data: funtion() &#123; return &#123; selfContent: this.content &#125; &#125;, props: &#123; content: String &#125;, template: &apos;&lt;div @click=&quot;handleClick&quot;&gt;&#123;&#123;selfContent&#125;&#125;&lt;/div&gt;&apos; methods: &#123; handleClick: function() &#123; // 向外触发change事件 this.bus.$emit(&apos;change&apos;, this.selfContent) &#125; &#125;, mounted: function() &#123; let _this = this; // 监听change事件 this.bus.$on(&apos;change&apos;, function(msg) &#123; _this.selfContent = msg &#125;) &#125; &#125;)&lt;/script&gt; 当然除此之外我们可以通过 Vuex 来实现，Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式，这里就不详细介绍。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-router相关知识]]></title>
    <url>%2Fvue-router%2F</url>
    <content type="text"><![CDATA[解读 router/index.js12345678910111213import Vue from &apos;vue&apos; //引入Vueimport Router from &apos;vue-router&apos; //引入vue-routerimport Hello from &apos;@/components/Hello&apos; //引入根目录下的Hello.vue组件Vue.use(Router) //Vue全局使用Routerexport default new Router(&#123; routes: [ //配置路由，这里是个数组 &#123; //每一个链接都是一个对象 path: &apos;/&apos;, //链接路径 name: &apos;Hello&apos;, //路由名称， component: Hello //对应的组件模板 &#125; ]&#125;) vue-router传参一. 用name传参1.在src/router/index.js例配置name属性1234567routes: [&#123; path: &apos;/&apos;, name: &apos;Hello&apos;, component: Hello&#125;] 2.模板里(src/App.vue)用$route.name的形式接收，比如直接在模板中显示：1&lt;p&gt;&#123;&#123; $route.name&#125;&#125;&lt;/p&gt; 二. 用标签中的to传参1&lt;router-link :to=&quot;&#123;name:xxx,params:&#123;key:value&#125;&#125;&quot;&gt;valueString&lt;/router-link&gt; 这里的to前边是带冒号的，然后后边跟的是一个对象形式的字符串. name:就是在路由配置文件中起的name值。 params:就是我们要传的参数，它也是对象形式，在对象里可以传递多个值。 vue-router 利用url传递参数:冒号的形式传递参数 我们可以在理由配置文件里以:冒号的形式传递参数，这就是对参数的绑定。 1234&#123; path:&apos;/params/:newsId/:newsTitle&apos;, component:Params&#125; 在src/components目录下建立我们params.vue组件，也可以说是页面。我们在页面里输出了url传递的的新闻ID和新闻标题。 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; msg &#125;&#125;&lt;/h2&gt; &lt;p&gt;新闻ID：&#123;&#123; $route.params.newsId&#125;&#125;&lt;/p&gt; &lt;p&gt;新闻标题：&#123;&#123; $route.params.newsTitle&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;params&apos;, data () &#123; return &#123; msg: &apos;params page&apos; &#125; &#125;&#125;&lt;/script&gt; 在App.vue文件里加入我们的标签。这时候我们可以直接利用url传值了。 1&lt;router-link to=&quot;/params/198/jspang website is very good&quot;&gt;params&lt;/router-link&gt; redirect和aliasredirect基本重定向我们只要在路由配置文件中（/src/router/index.js）把原来的component换成redirect参数就可以了。我们来看一个简单的配置。1234567891011121314export default new Router(&#123; routes: [ &#123; path: &apos;/&apos;, component: Hello &#125;,&#123; path:&apos;/params/:newsId(\\d+)/:newsTitle&apos;, component:Params &#125;,&#123; path:&apos;/goback&apos;, redirect:&apos;/&apos; &#125; ]&#125;) alias别名使用 首先我们在路由配置文件里（/src/router/index.js），给上节课的Home路径起一个别名，hdy。 12345&#123; path: &apos;/hi1&apos;, component: Hi1, alias:&apos;/hdy&apos; &#125; 配置我们的，起过别名之后，可以直接使用标签里的to属性，进行重新定向。 1&lt;router-link &lt; to=&quot;/hdy&quot;&gt;jspang&lt;/router-link&gt; redirect和alias的区别 redirect：仔细观察URL，redirect是直接改变了url的值，把url变成了真实的path路径。 URL路径没有别改变，这种情况更友好，让用户知道自己访问的路径，只是改变了&lt;router-view&gt;中的内容。 路由的过渡动画&lt;transition&gt;标签想让路由有过渡动画，需要在&lt;router-view&gt;标签的外部添加&lt;transition&gt;标签，标签还需要一个name属性。123&lt;transition name=&quot;fade&quot;&gt; &lt;router-view &gt;&lt;/router-view&gt;&lt;/transition&gt; css过渡类名:组件过渡过程中，会有四个CSS类名进行切换，这四个类名与transition的name属性有关，比如name=”fade”,会有如下四个CSS类名： fade-enter:进入过渡的开始状态，元素被插入时生效，只应用一帧后立刻删除。 fade-enter-active:进入过渡的结束状态，元素被插入时就生效，在过渡过程完成后移除。 fade-leave:离开过渡的开始状态，元素被删除时触发，只应用一帧后立刻删除。 fade-leave-active:离开过渡的结束状态，元素被删除时生效，离开过渡完成后被删除。 过渡模式mode： in-out:新元素先进入过渡，完成之后当前元素过渡离开。(默认) out-in:当前元素先进行过渡离开，离开完成后新元素过渡进入。 路由属性mode history：在此模式下url没有#号，较好看 hash：默认模式，url带有模式hash值 404页面用户会经常输错页面，当用户输错页面时，我们希望给他一个友好的提示，为此美工都会设计一个漂亮的页面，这个页面就是我们常说的404页面。 路由配置1234&#123; path:&apos;*&apos;, component:Error&#125; 路由中的钩子路由配置文件中的钩子函数 我们可以直接在路由配置文件（/src/router/index.js）中写钩子函数。但是在路由文件中我们只能写一个beforeEnter,就是在进入此路由配置时。123456789&#123; path:&apos;/params/:newsId(\\d+)/:newsTitle&apos;, component:Params, beforeEnter:(to,from,next)=&gt;&#123; console.log(&apos;我进入了params模板&apos;); console.log(to); console.log(from); next();&#125;, 三个参数： to：路由将要跳转的路径信息，信息是包含在对象里边的。 from：路径跳转前的路径信息，也是一个对象的形式。 next：路由的控制参数，常用的有next(true)和next(false)。 写在模板中的钩子函数在模板中就可以有两个钩子函数可以使用： beforeRouteEnter：在路由进入前的钩子函数。 beforeRouteLeave：在路由离开前的钩子函数。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue的基础知识点]]></title>
    <url>%2Fvue-basis%2F</url>
    <content type="text"><![CDATA[一、全局APIVue.directive自定义指令 自定义指令传递的三个参数 el: 指令所绑定的元素，可以用来直接操作DOM。 binding: 一个对象，包含指令的很多信息。 vnode: Vue编译生成的虚拟节点。 自定义指令的生命周期自定义指令有五个生命周期（也叫钩子函数），分别是bind, inserted, update, componentUpdated, unbind bind:只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个绑定时执行一次的初始化动作。 inserted:被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于document中）。 update:被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。 componentUpdated:被绑定元素所在模板完成一次更新周期时调用。 unbind:只调用一次，指令与元素解绑时调用。 Vue-setVue.set 的作用就是在构造器外部操作构造器内部的数据、属性或者方法。 为什么要有Vue.set的存在? 由于Javascript的限制，Vue不能自动检测以下变动的数组。 当你利用索引直接设置一个项时，vue不会为我们自动更新。 当你修改数组的长度时，vue不会为我们自动更新。 Vue的生命周期 钩子函数123456789101112131415161718192021222324252627282930beforeCreate:function()&#123; console.log(&apos;1-beforeCreate 初始化之后&apos;);&#125;,created:function()&#123; console.log(&apos;2-created 创建完成&apos;);&#125;,beforeMount:function()&#123; console.log(&apos;3-beforeMount 挂载之前&apos;);&#125;,mounted:function()&#123; console.log(&apos;4-mounted 被创建&apos;);&#125;,beforeUpdate:function()&#123; console.log(&apos;5-beforeUpdate 数据更新前&apos;);&#125;,updated:function()&#123; console.log(&apos;6-updated 被更新后&apos;);&#125;,activated:function()&#123; console.log(&apos;7-activated&apos;);&#125;,deactivated:function()&#123; console.log(&apos;8-deactivated&apos;);&#125;,beforeDestroy:function()&#123; console.log(&apos;9-beforeDestroy 销毁之前&apos;);&#125;,destroyed:function()&#123; console.log(&apos;10-destroyed 销毁之后&apos;)&#125; Template模板 直接写在选项里，适合较短的html代码 写在template标签里，适合长的html代码 写在script标签里，适合外部引入模板文件 组件Component组件就是自定义的标签 全局化注册组件全局化就是在构造器的外部用Vue.component来注册 局部注册组件局部注册组件局部注册组件和全局注册组件是相对应的，局部注册的组件只能在组件注册的作用域里进行使用，其他作用域使用无效。 组件和指令的区别组件注册的是一个标签，而指令注册的是已有标签里的一个属性。在实际开发中我们还是用组件比较多，指令用的比较少。因为指令看起来封装的没那么好，这只是个人观点。 Component 父子组件关系在实际开发中我们经常会遇到在一个自定义组件中要使用其他自定义组件，这就需要一个父子组件关系。 Component 标签标签是Vue框架自定义的标签，它的用途就是可以动态绑定我们的组件，根据数据的不同更换不同的组件。 二、实例实例方法 $mount 方法用来挂在扩展 $destroy() 卸载方法 $forceUpdate() 更新方法 $nextTick() 数据修改方法当Vue构造器里的data值被修改完成后会调用这个方法 实例事件 $on 在构造器外部添加事件$on接收两个参数，第一个参数是调用时的事件名称，第二个参数是一个匿名方法。 1234app.$on(&apos;reduce&apos;,function()&#123; console.log(&apos;执行了reduce()&apos;); this.num--;&#125;); $once 执行一次的事件 $off 关闭事件 1234//关闭事件function off()&#123; app.$off(&apos;reduce&apos;);&#125; slotslot是标签的内容扩展，也就是说你用slot就可以在自定义组件时传递给组件内容，组件接收内容并输出。 三、选项相关computed Option 计算选项computed 的作用主要是对原数据进行改造输出。改造输出：包括格式的编辑，大小写转换，顺序重排，添加符号……。 Methods Option 方法选项 methods中参数的传递使用方法和正常的javascript传递参数的方法一样，分为两部： 在methods的方法中进行声明，比如我们给add方法加上一个num参数，就要写出add:function(num){} 调用方法时直接传递，比如我们要传递2这个参数，我们在button上就直接可以写。@click=”add(2)”&gt;&lt;/button&gt; methods中的$event参数传递的$event参数都是关于你点击鼠标的一些事件和属性。 native 给组件绑定构造器里的原生事件在实际开发中经常需要把某个按钮封装成组件，然后反复使用，如何让组件调用构造器里的方法，而不是组件里的方法。就需要用到我们的.native修饰器了&lt;p&gt;&lt;btn @click.native=&quot;add(3)&quot;&gt;&lt;/btn&gt;&lt;/p&gt; 作用域外部调用构造器里的方法&lt;button onclick=&quot;app.add(4)&quot; &gt;&lt;/button&gt;不常用，不提倡用 Mixins 混入选项操作 Mixins一般有两种用途： 在你已经写好了构造器后，需要增加方法或者临时的活动时使用的方法，这时用混入会减少源代码的污染。 很多地方都会用到的公用方法，用混入的方法可以减少代码量，实现代码重用。 mixins的调用顺序全局-&gt;混入-&gt;构造器里PS：当混入方法和构造器的方法重名时，混入的方法无法展现，也就是不起作用。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6解构赋值与函数相关知识点]]></title>
    <url>%2Fes6-function%2F</url>
    <content type="text"><![CDATA[一、箭头函数注意点 箭头函数有几个使用注意点： （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 this对象的指向一般是可变的，但是在箭头函数中，它是固定的。12345678910function foo() &#123; setTimeout(() =&gt; &#123; console.log(&apos;id:&apos;, this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// id: 42 上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。 箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。1234567891011121314151617function Timer() &#123; this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() =&gt; this.s1++, 1000); // 普通函数 setInterval(function () &#123; this.s2++; &#125;, 1000);&#125;var timer = new Timer();setTimeout(() =&gt; console.log(&apos;s1: &apos;, timer.s1), 3100);setTimeout(() =&gt; console.log(&apos;s2: &apos;, timer.s2), 3100);// s1: 3// s2: 0 上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，timer.s1被更新了 3 次，而timer.s2一次都没更新。 箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面。123456789101112var handler = &#123; id: &apos;123456&apos;, init: function() &#123; document.addEventListener(&apos;click&apos;, event =&gt; this.doSomething(event.type), false); &#125;, doSomething: function(type) &#123; console.log(&apos;Handling &apos; + type + &apos; for &apos; + this.id); &#125;&#125;; 上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。 所以，箭头函数转成 ES5 的代码如下。123456789101112131415// ES6function foo() &#123; setTimeout(() =&gt; &#123; console.log(&apos;id:&apos;, this.id); &#125;, 100);&#125;// ES5function foo() &#123; var _this = this; setTimeout(function () &#123; console.log(&apos;id:&apos;, _this.id); &#125;, 100);&#125; 上面代码中，可以看出箭头函数里面根本没有自己的this，而是引用外层的this。 请问下面的代码之中有几个this？123456789101112131415function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log(&apos;id:&apos;, this.id); &#125;; &#125;; &#125;;&#125;var f = foo.call(&#123;id: 1&#125;);var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1var t2 = f().call(&#123;id: 3&#125;)(); // id: 1var t3 = f()().call(&#123;id: 4&#125;); // id: 1 上面代码之中，只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。 除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。12345678function foo() &#123; setTimeout(() =&gt; &#123; console.log(&apos;args:&apos;, arguments); &#125;, 100);&#125;foo(2, 4, 6, 8)// args: [2, 4, 6, 8] 上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。 另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。123456(function() &#123; return [ (() =&gt; this.x).bind(&#123; x: &apos;inner&apos; &#125;)() ];&#125;).call(&#123; x: &apos;outer&apos; &#125;);// [&apos;outer&apos;] 上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。 长期以来，JavaScript 语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。箭头函数”绑定”this，很大程度上解决了这个困扰。 二、双冒号运算符箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以现在有一个提案，提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。 函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。123456789101112foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments);const hasOwnProperty = Object.prototype.hasOwnProperty;function hasOwn(obj, key) &#123; return obj::hasOwnProperty(key);&#125; 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。1234567var method = obj::obj.foo;// 等同于var method = ::obj.foo;let log = ::console.log;// 等同于var log = console.log.bind(console); 如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法。123456import &#123; map, takeWhile, forEach &#125; from &quot;iterlib&quot;;getPlayers()::map(x =&gt; x.character())::takeWhile(x =&gt; x.strength &gt; 100)::forEach(x =&gt; console.log(x)); 三、解构赋值解构赋值默认值与函数参数默认值123456789// 写法一function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;// 写法二function m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125; 写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。123456789101112131415161718// 函数没有参数的情况m1() // [0, 0]m2() // [0, 0]// x 和 y 都有值的情况m1(&#123;x: 3, y: 8&#125;) // [3, 8]m2(&#123;x: 3, y: 8&#125;) // [3, 8]// x 有值，y 无值的情况m1(&#123;x: 3&#125;) // [3, 0]m2(&#123;x: 3&#125;) // [3, undefined]// x 和 y 都无值的情况m1(&#123;&#125;) // [0, 0];m2(&#123;&#125;) // [undefined, undefined]m1(&#123;z: 3&#125;) // [0, 0]m2(&#123;z: 3&#125;) // [undefined, undefined] 函数的length属性指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。123(function (a) &#123;&#125;).length // 1(function (a = 5) &#123;&#125;).length // 0(function (a, b, c = 5) &#123;&#125;).length // 2 上面代码中，length属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3 个参数，其中有一个参数c指定了默认值，因此length属性等于3减去1，最后得到2。 这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入length属性。1(function(...args) &#123;&#125;).length // 0 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。12(function (a = 0, b, c) &#123;&#125;).length // 0(function (a, b = 1, c) &#123;&#125;).length // 1 本文参考自阮一峰大神的《ES6标准入门》原文链接：http://es6.ruanyifeng.com/]]></content>
      <categories>
        <category>JavaScript学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中的数组相关知识点]]></title>
    <url>%2Fjs-array%2F</url>
    <content type="text"><![CDATA[1.数组的每一项可以用来保存任何类型的数据 2.可以通过length属性在数组末尾移除项或向数组添加新项123var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; //creates an array with three stringscolors.length = 2;alert(colors[2]); //undefined 123var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; //creates an array with three stringscolors.length = 4;alert(colors[3]); //undefined 3.alert()方法要接收字符串参数时会在后台调用toString()方法，都是创建一个数组值的以逗号分隔的字符串 4.join()方法可以使用不同的分隔符来构建字符串123var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];alert(colors.join(&quot;,&quot;)); //red,green,bluealert(colors.join(&quot;||&quot;)); //red||green||blue 5.栈和队列 push()返回添加后的数组长度，而pop()返回移除的项,二者实现类似栈行为 shift()移除数组中第一个项并返回该项，数组长度减一，和push()结合模拟队列 unshift()在数组前端添加任意个项并返回新数组长度，与pop()结合从相反方向模拟队列 6.重排序方法 reverse()反转数组项顺序 sort()调用每个数组项的toString()，比较得到的字符串确定排序，即是数组项是数值 7.操作方法concat()基于当前数组中的所有项创建一个新数组1234var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];var colors2 = colors.concat(&quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]);alert(colors); //red,green,blue alert(colors2); //red,green,blue,yellow,black,brown slice()基于当前数组的一或多项创建一个新数组 12345var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;];var colors2 = colors.slice(1);var colors3 = colors.slice(1,4);alert(colors2); //green,blue,yellow,purplealert(colors3); //green,blue,yellow splice() 删除：可以删除任意数量的项，参数为要删除的第一项位置和要删除的项数 1234var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];var removed = colors.splice(0,1); //remove the first itemalert(colors); //green,bluealert(removed); //red - one item array 插入：向指定位置插入任意数量的项，需提供3个参数：起始位置、0（要删除的项数）和要插入的项。例如，splice(2,0,”red”,”green”)会从当前数组的位置2开始插入字符串red和green 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项。3个参数：起始位置、要删除的项数和要插入的任意数量的项。例如，splice(2,1,”red”,”green”)会删除当前数组位置2的项，然后再从位置2开始插入red和green 8.位置方法indexOf()和lastIndexOf()都有2个参数：要查找的项和（可选）表示查找起点位置的索引，返回查找项的位置，没找到返回-1。indexOf()正向查找，lastIndexOf()反向 9.迭代方法2个参数：要在每一项上运行的函数和（可选）运行该函数的作用域对象；其中的函数有3个参数：数组项的值、该项在数组中的位置和数组对象本身 every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组 forEach()：对数组中的每一项运行给定函数，无返回值 map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组 some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true 10.归并方法2个参数：一个在每一项上调用的函数和（可选）作为归并基础的初始值；其中的函数有4个参数：前一个值、当前值、项的索引和数组对象，函数的返回值作为第一参数传给下一项，第一个参数时数组的第一项，第二个参数时数组的第二项 reduce()从数组第一项开始逐个遍历 reduceRight()从数组最后一项开始，反向遍历]]></content>
      <categories>
        <category>JavaScript学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2FgitCommand%2F</url>
    <content type="text"><![CDATA[一、新建代码库123git init 在当前目录新建一个Git代码库 git init [project-name] 新建一个目录，将其初始化为Git代码库 git clone [url] 下载一个项目和它的整个代码历史 二、配置1234git config --list 显示当前的Git配置git config -e [--global] 编辑Git配置文件git config [--global] user.name &quot;[name]&quot; git config [--global] user.email &quot;[email address]&quot; 设置提交代码时的用户信息 三、添加/删除/修改文件123456789git status 查看状态git diff 查看变更内容git add [file1] [file2] ... 添加指定文件到暂存区git add [dir] 添加指定目录到暂存区，包括子目录git add . 添加当前目录的所有文件到暂存区git add -p 添加每个变化前，都会要求确认 对于同一个文件的多处变化，可以实现分次提交 git rm [file1] [file2] ...删除工作区文件，并且将这次删除放入暂存区git rm --cached [file] 停止追踪指定文件，但该文件会保留在工作区git mv [file-original] [file-renamed] 改名文件，并且将这个改名放入暂存区 四、代码提交123456git commit -m [message] 提交暂存区到仓库区git commit [file1] [file2] ... -m [message]提交暂存区的指定文件到仓库区git commit -a 提交工作区自上次commit之后的变化，直接到仓库区git commit -v提交时显示所有diff信息git commit --amend -m [message] 使用一次新的commit，替代上一次提交 如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend [file1] [file2] ... 重做上一次commit，并包括指定文件的新变化 五、分支123456789101112131415git branch 显示所有本地分支git branch -r 列出所有远程分支git branch -a 列出所有本地分支和远程分支git branch [branch-name] 新建一个分支，但依然停留在当前分支git branch --track [branch] [remote-branch] 新建一个分支，与指定的远程分支建立追踪关系git branch -d [branch-name] 删除分支git push origin --detele [branch-name] git branch -dr [remote/branch] 删除远程分支git checkout -b [branch] 新建一个分支，并切换到该分支git checkout [branch-name] 切换到指定分支，并更新工作区git checkout - 切换到上一个分支git branch --set -upstream [branch] [remote-branch] 建立追踪关系，在现有分支与指定的远程分支之间git merge [branch] 合并指定分支到当前分支git rebase &lt;branch&gt; 衍合指定分支到当前分支git cherry-pick [commit] 选择一个commit，合并到当前分支 六、标签12345678git tag 列出所有本地标签git tag &lt;tag-name&gt; 基于最新的提交创建标签git tag -d &lt;tag-name&gt; 删除指定标签git push origin :refs/tags/[tag-name] 删除远程标签git show [tag] 查看标签信息git push [remote] [tag] 提交指定标签git push [remote] --tags 提交所有标签git checkout -b [branch] [tag] 新建一个分支，指向某个标签 七、查看信息123456789101112131415161718192021git status 显示有变更的文件git log 显示当前分支的版本历史git log --stat 显示提交历史，以及每次提交发生变更的文件git log -S [keyword] 根据关键词搜索提交历史git log [tag] HEAD --pretty=format:%s 显示某个提交之后的所有变动git log [tag] HEAD --grep featuregit log --follow [file]git whatchanged [file] 显示某个文件的版本历史，包括文件改名git log -p [file] 显示指定文件相关的每一次diffgit log -5 --pretty --online 显示过去5次提交git shortlog -sn 显示所有提交过的用户，按提交次数排序git blame [file] 显示指定文件是何人何时修改信息git diff 显示暂存区与工作区的差异git diff --cached [file] 显示暂存区和上一个提交的差异git diff HEAD 显示工作区与当前分支最新调教之间的差异git diff [first-branch]...[second-branch] 显示两次提交之间的差异git diff --short stat &quot;@&#123;0 day ago&#125;&quot; 显示今天你写了多少行代码git show [commit] 显示某次提交的元数据和内容变化git show --name-only [commit] 显示某次提交发生变化的文件gitshow [commit]:[filename] 显示某次提交时，某个文件的内容git reflog 显示当前分支的最近几次提交 八、远程操作12345678910git fetch [remote] 下载远程仓库的所有变动git pull [remote] [branch] 取回远程参股的变化，并与本地分支合并git remote -v 显示所有远程仓库git remote show [remote] 显示某个远程仓库的信息git remote add [shortname] [url] 增加一个新的远程仓库git push [remote] [branch] 上传本地指定分支到远程仓库git push [remote] --force 强制推送当前分支到远程仓库git push [remote] --all 推动所有分支到远程仓库git push &lt;remote&gt; 删除远程分支或标签git push --tags 上传所有标签 九、撤销123456789101112131415git reset --hard HEAD 撤销工作目录中所有未提交文件的修改内容git checkout HEAD &lt;file&gt; 撤销指定的未提交文件的修改内容git revert &lt;commit&gt; 撤销指定的提交git log --before=&quot;1 days&quot; 退回到之前1天的版本git checkout [file] 恢复暂存区的指定文件到工作区git checkout [commit] [file] 恢复某个提交的指定文件到暂存区和工作区git checkout . 恢复暂存区的所有文件到工作区git reset [file] 重置暂存区的指定文件，遇上一次提交保持一致，但工作区不变git reset --hard 重置暂存区与工作区，与上次提交保持一致git reset [commit] 重置当前分支的指针为指定提交，同时重置暂存区，但工作区不变git reset --hard [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --keep [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变git revert [commit] 新建一个commit，用来撤销指定commit，后者的所有变化豆浆杯前者抵消，并且应用到当前分支git stashgit stash pop 暂时将未提交的变化移除，稍后再移入]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
