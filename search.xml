<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS隐式转换]]></title>
    <url>%2FImplicitConversion.html</url>
    <content type="text"><![CDATA[三种隐式转换类型涉及隐式转换最多的两个运算符 + 和 ==。 +运算符即可数字相加，也可以字符串相加。所以转换时很麻烦。== 不同于===，故也存在隐式转换。- * / 这些运算符只会针对number类型，故转换的结果只能是转换成number类型。 隐式转换中主要涉及到三种转换： 将值转为原始值，ToPrimitive()。 将值转为数字，ToNumber()。 将值转为字符串，ToString()。 通过ToPrimitive将值转换为原始值js引擎内部的抽象操作ToPrimitive有着这样的签名：ToPrimitive(input, PreferredType?)input是要转换的值，PreferredType是可选参数，可以是Number或String类型。他只是一个转换标志，转化后的结果并不一定是这个参数所值的类型，但是转换结果一定是一个原始值（或者报错）。 如果PreferredType被标记为Number，则会进行下面的操作流程来转换输入的值。 如果输入的值已经是一个原始值，则直接返回它 否则，如果输入的值是一个对象，则调用该对象的valueOf()方法， 如果valueOf()方法的返回值是一个原始值，则返回这个原始值。 否则，调用这个对象的toString()方法，如果toString()方法返回的是一个原始值，则返回这个原始值。 否则，抛出TypeError异常。 如果PreferredType被标记为String，则会进行下面的操作流程来转换输入的值。 如果输入的值已经是一个原始值，则直接返回它 否则，如果输入的值是一个对象，则调用该对象的toString()方法， 如果toString()方法的返回值是一个原始值，则返回这个原始值。 否则，调用这个对象的valueOf()方法，如果valueOf()方法返回的是一个原始值，则返回这个原始值。 否则，抛出TypeError异常。 如果PreferredType没有值，会按以下规则处理 该对象为Date类型，则PreferredType被设置为String 否则，PreferredType被设置为Number 原因：因为valueOf函数会将Number、String、Boolean基础类型的对象类型值转换成 基础类型，Date类型转换为毫秒数，其它的返回对象本身，而toString方法会将所有对象转换为字符串。显然对于大部分对象转换，valueOf转换更合理些，因为并没有规定转换类型，应该尽可能保持原有值，而不应该想toString方法一样，将其转换为字符串。而对于Date类型，其进行valueOf转换为毫秒数的number类型。在进行隐式转换时，没有指定将其转换为number类型时，将其转换为那么大的number类型的值显然没有多大意义。（不管是在+运算符还是==运算符）还不如转换为字符串格式的日期，所以默认Date类型会优先进行toString转换。 valueOf方法和toString方法解析 Object.prototype中有valueOf和toString方法，故任何对象都会有这两个方法。 valueOf转换结果： Number、Boolean、String这三种构造函数生成的基础值的对象形式，通过valueOf转换后会变成相应的原始值。 12345678var num = new Number('123');num.valueOf(); // 123var str = new String('12df');str.valueOf(); // '12df'var bool = new Boolean('fd');bool.valueOf(); // true Date这种特殊的对象，其原型Date.prototype上内置的valueOf函数将日期转换为日期的毫秒的形式的数值。 12var a = new Date();a.valueOf(); // 1515143895500 除此之外返回的都为this，即对象本身 12345var a = new Array();a.valueOf() === a; // truevar b = new Object(&#123;&#125;);b.valueOf() === b; // true toString转换结果： Number、Boolean、String、Array、Date、RegExp、Function这几种构造函数生成的对象，通过toString转换后会变成相应的字符串的形式，因为这些构造函数上封装了自己的toString方法。 12345678910111213141516171819202122232425Number.prototype.hasOwnProperty('toString'); // trueBoolean.prototype.hasOwnProperty('toString'); // trueString.prototype.hasOwnProperty('toString'); // trueArray.prototype.hasOwnProperty('toString'); // trueDate.prototype.hasOwnProperty('toString'); // trueRegExp.prototype.hasOwnProperty('toString'); // trueFunction.prototype.hasOwnProperty('toString'); // truevar num = new Number('123sd');num.toString(); // 'NaN'var str = new String('12df');str.toString(); // '12df'var bool = new Boolean('fd');bool.toString(); // 'true'var arr = new Array(1,2);arr.toString(); // '1,2'var d = new Date();d.toString(); // "Wed Oct 11 2017 08:00:00 GMT+0800 (中国标准时间)"var func = function () &#123;&#125;func.toString(); // "function () &#123;&#125;" 其他对象返回的都是该对象的类型 1234var obj = new Object(&#123;&#125;);obj.toString(); // "[object Object]"Math.toString(); // "[object Math]" 通过ToNumber将值转换为数字根据参数类型进行下面转换： 参数 结果 undefined NaN null +0 布尔值 true转换1，false转换为+0 数字 无须转换 字符串 有字符串解析为数字，例如：‘324’转换为324，‘qwer’转换为NaN 对象(obj) 先进行 ToPrimitive(obj, Number)转换得到原始值，再进行ToNumber转换为数字 通过ToString将值转换为字符串根据参数类型进行下面转换： 参数 结果 undefined ‘undefined’ null ‘null’ 布尔值 转换为’true’ 或 ‘false’ 数字 数字转换字符串，比如：1.765转为’1.765’ 字符串 无须转换 对象(obj) 先进行 ToPrimitive(obj, String)转换得到原始值，再进行ToString转换为字符串 例子解析 12345672 * &#123;&#125; = ?1、首先*运算符只能对number类型进行运算，故第一步就是对&#123;&#125;进行ToNumber类型转换。2、由于&#123;&#125;是对象类型，故先进行原始类型转换，ToPrimitive(input, Number)运算。3、所以会执行valueOf方法，(&#123;&#125;).valueOf(),返回的还是&#123;&#125;对象，不是原始值。4、继续执行toString方法，(&#123;&#125;).toString(),返回"[object Object]"，是原始值。5、转换为原始值后再进行ToNumber运算，"[object Object]"就转换为NaN。故最终的结果为 2 * NaN = NaN ==隐式转换规则如下： 1234567891011121314151617181920212223比较运算 x==y, 其中 x 和 y 是值，返回 true 或者 false。这样的比较按如下方式进行：1、若 Type(x) 与 Type(y) 相同， 则 1* 若 Type(x) 为 Undefined， 返回 true。 2* 若 Type(x) 为 Null， 返回 true。 3* 若 Type(x) 为 Number， 则 (1)、若 x 为 NaN， 返回 false。 (2)、若 y 为 NaN， 返回 false。 (3)、若 x 与 y 为相等数值， 返回 true。 (4)、若 x 为 +0 且 y 为 −0， 返回 true。 (5)、若 x 为 −0 且 y 为 +0， 返回 true。 (6)、返回 false。 4* 若 Type(x) 为 String, 则当 x 和 y 为完全相同的字符序列（长度相等且相同字符在相同位置）时返回 true。 否则， 返回 false。 5* 若 Type(x) 为 Boolean, 当 x 和 y 为同为 true 或者同为 false 时返回 true。 否则， 返回 false。 6* 当 x 和 y 为引用同一对象时返回 true。否则，返回 false。2、若 x 为 null 且 y 为 undefined， 返回 true。3、若 x 为 undefined 且 y 为 null， 返回 true。4、若 Type(x) 为 Number 且 Type(y) 为 String，返回比较 x == ToNumber(y) 的结果。5、若 Type(x) 为 String 且 Type(y) 为 Number，返回比较 ToNumber(x) == y 的结果。6、若 Type(x) 为 Boolean， 返回比较 ToNumber(x) == y 的结果。7、若 Type(y) 为 Boolean， 返回比较 x == ToNumber(y) 的结果。8、若 Type(x) 为 String 或 Number，且 Type(y) 为 Object，返回比较 x == ToPrimitive(y) 的结果。9、若 Type(x) 为 Object 且 Type(y) 为 String 或 Number， 返回比较 ToPrimitive(x) == y 的结果。10、返回 false。 总结以上规则： 类型相同时，没有类型转换，主要注意NaN不与任何值相等，包括它自己，即NaN !== NaN。 类型不相同时， x,y 为null、undefined两者中一个 // 返回true x、y为Number和String类型时，则转换为Number类型比较。 有Boolean类型时，Boolean转化为Number类型比较。 一个Object类型，一个String或Number类型，将Object类型进行原始转换后，按上面流程进行原始值比较。 例子解析： 1234567891011[] == !&#123;&#125;//1、! 运算符优先级高于==，故先进行！运算。2、!&#123;&#125;运算结果为false，结果变成 [] == false比较。3、根据上面第7条，等式右边y = ToNumber(false) = 0。结果变成 [] == 0。4、按照上面第9条，比较变成ToPrimitive([]) == 0。 按照上面规则进行原始值转换，[]会先调用valueOf函数，返回this。 不是原始值，继续调用toString方法，x = [].toString() = ''。 故结果为 '' == 0比较。5、根据上面第5条，等式左边x = ToNumber('') = 0。 所以结果变为： 0 == 0，返回true，比较结束。 参考链接： keenjaan 《你所忽略的js隐式转换》]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防抖和节流]]></title>
    <url>%2Fdebance.html</url>
    <content type="text"><![CDATA[一、防抖1.定义指触发事件后在规定时间内回调函数只能执行一次，如果在规定时间内又触发了该事件，则会重新开始计算规定时间。 2.应用场景满足两个条件的场景： 用户连续的操作会导致频繁的时间回调，如频繁发送请求。 用户只关心“最后一次”操作的结果。 例如： 表单验证填写内容时，等用户在连续输入后停下一段时间再验证。 按钮点击：点赞、收藏等 3.原理及实现通过定时器将回调函数进行延时，如果在规定时间内继续回调，发现存在之前的定时器，则将该定时器清除，并重新设置定时器。 防抖分为两个版本 非立即执行版：事件触发-&gt;延时-&gt;执行回调函数；事件触发时会创建一个定时器，如果发现存在定时器，则会清除定时器，重新定时，定时结束后执行回调函数。 12345678910111213141516// 非立即执行版：// func是用户传入需要防抖的函数// delay是等待时间const debounce = (func, delay = 50) =&gt; &#123; // 缓存一个定时器id let timer = null // 这里返回的函数是每次用户实际调用的防抖函数 // 如果已经设定过定时器了就清空上一次的定时器 // 开始一个新的定时器，延迟执行回调函数 return function() &#123; if (timer) clearTimeout(timer) timer = setTimeout(() =&gt; &#123; func.apply(this, arguments) &#125;, delay) &#125;&#125; 立即执行版本：事件触发-&gt;执行回调函数-&gt;延时；事件触发时如果定时器不存在则会立即执行回调函数，如果存在则会重新设置定时器，该定时器延迟一定时间后会将自身清除。 123456789101112131415// 立即执行版：const debounce = (func, delay = 50) =&gt; &#123; let timer = null return function() &#123; if (timer) &#123; clearTimeout(timer) &#125; else &#123; func.apply(this, arguments) //如果定时器不存在，则说明延时已过，可以立即执行函数 &#125; //不管上一个延时是否完成，都需要重置定时器 timer = setTimeout(() =&gt; &#123; timer = null //到时间后，定时器自动设为null，不仅方便判断定时器状态还能避免内存泄露 &#125;, delay) &#125;&#125; 综合版本（带立即执行选项） 12345678910111213141516const debounce = (func， delay = 50， immediate = true) =&gt; &#123; let timer = null return function() &#123; if (timer) clearTimeout(timer) if (immediate) &#123; if (!timer) func.apply(this, arguments) timer = setTimeout(() =&gt; &#123; timer = null &#125;, delay) &#125; else &#123; timer = setTimeout(() =&gt; &#123; func.call(this, arguments) &#125;, delay); &#125; &#125;&#125; 二、节流1.定义当持续触发事件时，在规定时间段内只能调用一次回调函数。如果在规定时间内又触发了该事件，则什么也不做，也不会重置定时器。与防抖比较：防抖是将多次执行变为一次执行，节流是将多次执行变为在一定时间内只执行一次。 2.应用场景满足两个条件的场景： 用户连续频繁地触发事件。 用户不再只关心”最后一次”操作后的结果反馈，而是在操作过程中持续的反馈。 例如： 鼠标不断点击触发，点击事件在规定时间内只触发一次(单位时间内只触发一次)。 3.原理及实现节流有两种实现方式 时间戳方式：通过闭包保存上一次的时间戳，然后与事件触发的时间戳比较。如果大于规定时间，则执行回调函数，否则就什么都不处理。 特点：一般第一次会立即执行，之后连续频繁地触发事件，也是超过了规定时间才会执行一次。最后一次触发事件，也不会执行(说明：如果你最后一次触发时间大于规定时间，这样就算不上连续频繁触发了)。 1234567891011//时间戳版：const throttle = (func, delay = 50) =&gt; &#123; let previous = 0 // 记录上一次触发的时间戳.这里初始设为0,是为了确保第一次触发产生回调 return function() &#123; let now = Date.now() // 记录此刻触发时的时间戳 if (now - previous &gt; delay) &#123; //如果时间差大于规定时间,则触发 func.apply(this, arguments) previous = now &#125; &#125;&#125; 定时器方式：原理与防抖类似。通过闭包保存上一次定时器状态，然后事件触发时，如果定时器为null(即代表此时间隔已经大于规定时间)，则设置新的定时器，到时间后执行回调函数，并将定时器置为null。 特点：当第一次触发事件时，不会立即执行函数，到了规定时间后才会执行。之后连续频繁地触发事件，也是到了规定时间才会执行一次(因为定时器)。当最后一次停止触发后，由于定时器的延时，还会执行一次回调函数。一句话总结就是延时回调，你能看到的回调都是上次成功触发产生的，而不是你此刻触发产生的。 123456789101112//定时器版:const throttle = (func, delay = 50) =&gt; &#123; let timer return function() &#123; if (!timer) &#123; //如果定时器不存在,则设置新的定时器,到时后,才执行回调,并将定时器设为null timer = setTimeout(() =&gt; &#123; timer = null func.apply(this, arguments) &#125;, delay) &#125; &#125;&#125; 说明： 上面两个版本最大的区别是时间戳版的函数触发是在规定时间开始的时候，而定时器版的函数触发是在规定时间结束的时候 综合版本： 时间戳+定时器版: 实现第一次触发可以立即响应，结束触发后也能有响应 (该版才是最符合实际工作需求)。该版主体思路还是时间戳版，定时器的作用仅仅是执行最后一次回调1234567891011121314151617const throttle =&gt; (func, delay = 50) &#123; let timer = null let previous = 0 return function(args) &#123; let now = Date.now() let remaining = delay - (now - previous); //距离规定时间,还剩多少时间 clearTimeout(timer); //清除之前设置的定时器 if (remaining &lt;= 0) &#123; fun.apply(this, arguments) previous = Date.now() &#125; else &#123; timer = setTimeout(() =&gt; &#123; fun.apply(this, arguments) &#125;, remaining) //因为上面添加的clearTimeout.实际这个定时器只有最后一次才会执行 &#125; &#125;&#125; 参考链接 shotCat 《前端面试查漏补缺–(一) 防抖和节流》 yck 《前端面试之道》]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.14腾讯笔试题解]]></title>
    <url>%2Ftengxunexam.html</url>
    <content type="text"><![CDATA[可拖拽元素的实现题目描述：页面内有一个正方形元素，实现对其拖拽和放下，需要考虑窗口的边界情况。当时笔试这道题没能做出来，原因在于对浏览器中相关事件和元素坐标与视口宽高的属性不熟悉，虽然有基本思路，但把相关的时间和属性忘了也就难以实现了，后来自己查阅资料一步步实现了，也良好的处理了题中所说的便捷情况。大致思路就是利用鼠标事件，以及鼠标坐标和元素坐标，算出鼠标相对元素的偏移量，因为鼠标一按下该偏移量就固定了，就可以反过来用拖动时变化的鼠标坐标来算出变化的元素坐标，从而实现拖拽元素。而边界情况处理分为左上和右下，左上可控制元素坐标 x 或 y 小于零时对应元素的 left 或 top 为零，右下则可以通过视口宽高和元素宽高来限定元素坐标的最大值。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .move &#123; position: absolute; width: 100px; height: 100px; background: gray &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;div class="move"&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; let moveElem = document.querySelector('.move') //待拖拽元素 let windowHeight, windowWidth; // 窗口宽高 let elemHeight, elemWidth; // 元素宽高 let dragging; //是否激活拖拽状态 let tLeft, ElemTop; //鼠标按下时相对于选中元素的位移 //监听鼠标按下事件 document.addEventListener('mousedown', function (e) &#123; if (e.target == moveElem) &#123; let moveElemRect = moveElem.getBoundingClientRect() // 获取元素相对页面视口的位置 dragging = true; //激活拖拽状态 windowHeight = document.documentElement.clientHeight // 设置页面视口宽高 windowWidth = document.documentElement.clientWidth elemHeight = moveElem.clientHeight // 设置元素宽高 elemWidth = moveElem.clientWidth elemX = e.clientX - moveElemRect.left //鼠标按下时和选中元素的坐标偏移:x坐标 elemY = e.clientY - moveElemRect.top //鼠标按下时和选中元素的坐标偏移:y坐标 &#125; &#125;) //监听鼠标放开事件 document.addEventListener('mouseup', function (e) &#123; dragging = false &#125;) //监听鼠标移动事件 document.addEventListener('mousemove', function (e) &#123; if (dragging) &#123; let moveX = e.clientX - elemX // 拖拽时元素相对视口的坐标 let moveY = e.clientY - elemY moveElem.style.left = moveX + 'px' moveElem.style.top = moveY + 'px' if (moveX &lt; 0) &#123; // 处理边界情况 moveElem.style.left = 0 &#125; if (moveY &lt; 0) &#123; moveElem.style.top = 0 &#125; if (moveX + elemWidth &gt; windowWidth) &#123; moveElem.style.left = windowWidth - elemWidth + 'px' // 将left控制最大为视口宽度减去元素宽度 &#125; if (moveY + elemHeight &gt; windowHeight) &#123; moveElem.style.top = windowHeight - elemHeight + 'px' &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 大整数加法题目描述：实现大整数相加算法，两个数用字符串模拟函数原型：function add(a, b) {}当时这道题最后对进位没处理好，没能完全写对，很是惭愧，笔试结束后自己很快就正确的写出来了，只是相比其他人的解法不够优雅。这道题考验的主要是对大整数处理的算法，因为数值长度是有限的，所以用字符串处理大整数加法，不会溢出也不会损失精度。做法就是分治法，将字符串分割成个位数，处理个位数加法，最后再拼接成大整数字符串。 1234567891011121314151617181920212223242526272829303132function add(a, b) &#123; let result = []; // 结果 let len; let temp = 0; // 当前位相加结果 let count = 0; // 进位数 if (a.length &gt;= b.length) &#123; // 获取a和b中较大数的长度，并将较大的数赋给arrA，较小的给arrB len = a.length; arrA = a.split(''); arrB = b.split(''); &#125; else &#123; len = b.length; arrA = b.split(''); arrB = a.split(''); &#125; for (let i = 0; i &lt; len; i++) &#123; if (arrB.length) &#123; temp = Number(arrA.pop()) + Number(arrB.pop()) + count; // 将字符串转化成数字再相加 &#125; else &#123; temp = Number(arrA.pop()) + count; &#125; count = 0; if (temp &gt;= 10) &#123; // 当前位相加结果大于10则进位，并将结果减10 count = 1; temp = temp % 10; &#125; result.unshift(temp); // 将结果从数组前端推入 &#125; if (count != 0) &#123; // 对最后进位的处理 result.unshift(count) &#125; return result.join('') // 结果再转成字符串&#125; 在网上看到别人的解法 1234567891011function add(a,b)&#123; let res='', c=0; a = a.split(''); b = b.split(''); while (a.length || b.length || c)&#123; c += ~~a.pop() + ~~b.pop(); res = c % 10 + res; c = c&gt;9; &#125; return res;&#125; 这种解法将判断提炼成一行，不用判断哪个数大，直接将加法运算持续到最后的进位，而且只用一个变量c存储相加结果和进位，并且用~~来处理字符串到数字的转换 总结第一道题考的是BOM、鼠标事件的相关知识，第二道题就是算法题了，考的是对大整数的处理。两道题本质上都不难，也很经典，虽是如此，但想法和真正实现还是会有差距的，像我这样的前端新人，对两道题都有一定解题思路，但真正实现起来还是有各种bug，所以我觉得这次笔试还是值得记录下的。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>浏览器</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm scripts使用指南]]></title>
    <url>%2Fnpmscripts.html</url>
    <content type="text"><![CDATA[最近做了一套笔试题，上来第一二道题都是关于npm脚本的问题，以前没深入学习过，特此补充一下这方面的知识。 一、什么是npm脚本(npm scripts)？用过npm的人都知道 package.json 文件，它定义了一个项目所需要的各种模块，以及项目的配置信息。而npm允许在 package.json 文件里，使用 scripts 定义的脚本命令，这些脚本就称为npm脚本。123456&#123; // ... "scripts": &#123; "build": "node build.js" &#125;&#125; 上面代码是 package.json 文件的一个片段，里面的 scripts 字段是一个对象。它的每一个属性，对应一段脚本。比如，build 命令对应的脚本是 node build.js 。 命令行下使用 npm run 命令，就可以执行这段脚本。123$ npm run build# 等同于执行$ node build.js npm脚本的优点很多，如： 项目的相关脚本，可以集中在一个地方。 不同项目的脚本命令，只要功能相同，就可以有同样的对外接口。用户不需要知道怎么测试你的项目，只要运行 npm run test 即可。 可以利用 npm 提供的很多辅助功能。 查看当前项目的所有 npm 脚本命令，可以使用不带任何参数的 npm run 命令。1$ npm run 二、原理每当执行 npm run ，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。 比较特别的是，npm run 新建的这个 Shell，会将当前目录的 node_modules/.bin 子目录加入 PATH 变量，执行结束后，再将 PATH 变量恢复原样。 这意味着，当前目录的 node_modules/.bin 子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。比如，当前项目的依赖里面有 Mocha，只要直接写 mocha test 就可以了。1"test": "mocha test" 而不用写成下面这样。1"test": "./node_modules/.bin/mocha test" 由于 npm 脚本的唯一要求就是可以在 Shell 执行，因此它不一定是 Node 脚本，任何可执行文件都可以写在里面。 npm 脚本的退出码，也遵守 Shell 脚本规则。如果退出码不是0，npm 就认为这个脚本执行失败。 三、通配符由于 npm 脚本就是 Shell 脚本，因此可以使用 Shell 通配符。 12"lint": "jshint *.js""lint": "jshint **/*.js" 上面代码中，* 表示任意文件名，** 表示任意一层子目录。 如果要将通配符传入原始命令，防止被 Shell 转义，要将星号转义。 1"test": "tap test/\*.js" 四、传参我们可以向npm脚本传入参数，但要使用 -- 标明 1"lint": "jshint **.js" 向上面的 npm run lint 命令传入参数，必须写成下面这样。 1$ npm run lint -- --reporter checkstyle &gt; checkstyle.xml 也可以在 package.json 里面再封装一个命令。 12"lint": "jshint **.js","lint:checkstyle": "npm run lint -- --reporter checkstyle &gt; checkstyle.xml" 五、执行顺序如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。 如果是并行执行（即同时的平行执行），可以使用&amp;符号。 1$ npm run script1.js &amp; npm run script2.js 如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用&amp;&amp;符号。 1$ npm run script1.js &amp;&amp; npm run script2.js 这两个符号是 Bash 的功能。此外，还可以使用 node 的任务管理模块：script-runner、npm-run-all、redrun。 六、默认值一般来说，npm 脚本由用户提供。但是，npm 对两个脚本提供了默认值。也就是说，这两个脚本不用定义，就可以直接使用。 12"start": "node server.js"，"install": "node-gyp rebuild" 上面代码中，npm run start 的默认值是 node server.js，前提是项目根目录下有 server.js 这个脚本；npm run install 的默认值是 node-gyp rebuild，前提是项目根目录下有 binding.gyp 文件。 七、钩子npm 脚本有 pre 和 post 两个钩子。举例来说，build 脚本命令的钩子就是 prebuild 和 postbuild。 123"prebuild": "echo I run before the build script","build": "cross-env NODE_ENV=production webpack","postbuild": "echo I run after the build script" 用户执行 npm run build 的时候，会自动按照下面的顺序执行。 1npm run prebuild &amp;&amp; npm run build &amp;&amp; npm run postbuild 因此，可以在这两个钩子里面，完成一些准备工作和清理工作。下面是一个例子。 123"clean": "rimraf ./dist &amp;&amp; mkdir dist","prebuild": "npm run clean","build": "cross-env NODE_ENV=production webpack" npm 默认提供下面这些钩子。 prepublish，postpublish preinstall，postinstall preuninstall，postuninstall preversion，postversion pretest，posttest prestop，poststop prestart，poststart prerestart，postrestart 自定义的脚本命令也可以加上 pre 和 post 钩子。比如，myscript 这个脚本命令，也有 premyscript 和 postmyscript 钩子。不过，双重的 pre 和 post 无效，比如 prepretest 和 postposttest 是无效的。 npm 提供一个 npm_lifecycle_event 变量，返回当前正在运行的脚本名称，比如 pretest 、test、posttest 等等。所以，可以利用这个变量，在同一个脚本文件里面，为不同的 npm scripts 命令编写代码。请看下面的例子。 12345678910111213const TARGET = process.env.npm_lifecycle_event;if (TARGET === 'test') &#123; console.log(`Running the test task!`);&#125;if (TARGET === 'pretest') &#123; console.log(`Running the pretest task!`);&#125;if (TARGET === 'posttest') &#123; console.log(`Running the posttest task!`);&#125; 注意: prepublish 这个钩子不仅会在 npm publish 命令之前运行，还会在 npm install （不带任何参数）命令之前运行。这种行为很容易让用户感到困惑，所以 npm 4 引入了一个新的钩子 prepare，行为等同于 prepublish ，而从 npm 5 开始，prepublish 将只在 npm publish 命令之前运行。 八、简写形式四个常用的 npm 脚本有简写形式。 npm start 是 npm run start 的简写 npm stop 是 npm run stop 的简写 npm test 是 npm run test 的简写 npm restart 是 npm run stop &amp;&amp; npm run restart &amp;&amp; npm run start 的简写 npm start、npm stop 和 npm test 都比较好理解，而 npm restart 是一个复合命令，实际上会执行三个脚本命令：stop 、restart、start。具体的执行顺序如下: prerestart prestop stop poststop restart prestart start poststart postrestart 九、变量npm 脚本有一个非常强大的功能，就是可以使用 npm 的内部变量。首先，通过 npm_package_ 前缀，npm 脚本可以拿到 package.json 里面的字段。比如，下面是一个 package.json。 1234567&#123; "name": "foo", "version": "1.2.5", "scripts": &#123; "view": "node view.js" &#125;&#125; 那么，变量 npm_package_name 返回 foo，变量 npm_package_version 返回1.2.5。 123// view.jsconsole.log(process.env.npm_package_name); // fooconsole.log(process.env.npm_package_version); // 1.2.5 上面代码中，我们通过环境变量 process.env 对象，拿到 package.json 的字段值。如果是 Bash 脚本，可以用 $npm_package_name 和 $npm_package_version 取到这两个值。 npm_package_ 前缀也支持嵌套的 package.json 字段。 1234567"repository": &#123; "type": "git", "url": "xxx"&#125;,scripts: &#123; "view": "echo $npm_package_repository_type"&#125; 上面代码中，repository 字段的 type 属性，可以通过 npm_package_repository_type 取到。 下面是另外一个例子。 123"scripts": &#123; "install": "foo.js"&#125; 上面代码中，npm_package_scripts_install 变量的值等于 foo.js。 然后，npm 脚本还可以通过 npm_config_ 前缀，拿到 npm 的配置变量，即 npm config get xxx 命令返回的值。比如，当前模块的发行标签，可以通过 npm_config_tag 取到。 1"view": "echo $npm_config_tag" 注意:package.json 里面的 config 对象，可以被环境变量覆盖。 12345&#123; "name" : "foo", "config" : &#123; "port" : "8080" &#125;, "scripts" : &#123; "start" : "node server.js" &#125;&#125; 上面代码中，npm_package_config_port 变量返回的是8080。这个值可以用下面的方法覆盖。 1$ npm config set foo:port 80 最后，env 命令可以列出所有环境变量。 1"env": "env" 十、常用脚本示例1234567891011121314151617181920212223242526// 删除目录"clean": "rimraf dist/*",// 本地搭建一个 HTTP 服务"serve": "http-server -p 9090 dist/",// 打开浏览器"open:dev": "opener http://localhost:9090",// 实时刷新 "livereload": "live-reload --port 9091 dist/",// 构建 HTML 文件"build:html": "jade index.jade &gt; dist/index.html",// 只要 CSS 文件有变动，就重新执行构建"watch:css": "watch 'npm run build:css' assets/styles/",// 只要 HTML 文件有变动，就重新执行构建"watch:html": "watch 'npm run build:html' assets/html",// 部署到 Amazon S3"deploy:prod": "s3-cli sync ./dist/ s3://example-com/prod-site/",// 构建 favicon"build:favicon": "node scripts/favicon.js" 十一、参考链接 阮一峰 《npm scripts 使用指南》]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的this和call、apply、bind]]></title>
    <url>%2Fjs-this.html</url>
    <content type="text"><![CDATA[this是什么在JavaScript中，this是指函数作为方法被调用时所属的对象。我们可以看一下代码中函数的几种调用场景12345678910111213141516var a = 1function foo() &#123; console.log(this.a)&#125;// 全局下直接调用foo()const obj = &#123; a: 2, foo: foo&#125;// 作为对象方法调用obj.foo()// 用new操作符创建新实例const b = new foo() 在浏览器中，全局对象是 window，对于全局环境下直接调用 foo，this 一定是 window 作为对象方法调用时，谁调用了该函数，this 便指向谁，所以对于 obj.foo() 来说，函数中的 this 就是 obj 对象 对于 new 方式，this被永远绑定在 c 上，不能被任何方式改变 对于箭头函数，其本身并没有 this，箭头函数中的 this 只取决于包裹箭头函数的第一个普通函数的 this，并且箭头函数不能使用 apply、call、bind 函数来改变 this 的指向 当多种规则出现时，我们可以根据优先级来判断 this 的指向。首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。 apply、call和bind函数 call() 和 apply 两个方法作用相同，区别仅在于接受的参数的方式不同 function.apply(this.obj, args) 第二个参数 args 为数组或arguments对象 function.call(this.obj, args...) 第二个参数开始可接收任意多个参数二者第一个参数均为关键字 this 的值，参数为空时默认使用全局对象，浏览器中即为 window，最后都返回函数 function 的返回值。 bind() 与前两者不同，它的函数式为 function.bind(o, args...)，其中 o 为要绑定到函数上的对象，args... 为要绑定到函数上的零个或多个参数值，即可不带参数，最后返回一个作为对象 o 的方法来调用的新函数 对一个函数进行多次 bind ，函数的 this 永远由第一次决定，如以下代码12345678910111213let a = &#123;&#125;let fn = function () &#123; console.log(this)&#125;fn.bind().bind(a)() // window// fn.bind().bind(a) 等于let fn2 = function fn1() &#123; return function() &#123; return fn.apply() &#125;.apply(a)&#125;fn2() apply、call和bind的实现call 的实现:1234567891011Function.prototype.myCall = function(context) &#123; if (typeof this !== 'function') &#123; throw new TypeError('Error') &#125; context = context || window context.fn = this const args = [...arguments].slice(1) const result = context.fn(...args) delete context.fn return result&#125; 对实现的分析： 首先 context 为可选参数，如果不传的话默认上下文为 window 接下来给 context 创建一个 fn 属性，并将值设置为需要调用的函数 因为 call 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来 然后调用函数并将对象上的函数删除 apply 的实现:12345678910111213141516Function.prototype.myApply = function(context) &#123; if (typeof this !== 'function') &#123; throw new TypeError('Error') &#125; context = context || window context.fn = this let result // 处理参数和 call 有区别 if (arguments[1]) &#123; result = context.fn(...arguments[1]) &#125; else &#123; result = context.fn() &#125; delete context.fn return result&#125; 与 call 不同的是对参数的处理 bind 的实现:123456789101112131415Function.prototype.myBind = function (context) &#123; if (typeof this !== 'function') &#123; throw new TypeError('Error') &#125; const _this = this const args = [...arguments].slice(1) // 返回一个函数 return function F() &#123; // 因为返回了一个函数，我们可以 new F()，所以需要判断 if (this instanceof F) &#123; return new _this(...args, ...arguments) &#125; return _this.apply(context, args.concat(...arguments)) &#125;&#125; 对实现的分析: bind 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 new 的方式，我们先来说直接调用的方式 对于直接调用来说，这里选择了 apply 的方式实现，但是对于参数需要注意以下情况：因为 bind 可以实现类似这样的代码 f.bind(obj, 1)(2)，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 args.concat(...arguments) 最后来说通过 new 的方式，对于 new 的情况来说，不会被任何方式改变 this，所以对于这种情况我们需要忽略传入的 this new在调用 new 的过程中会发生以上四件事情： 新生成了一个对象 链接到原型 绑定 this 返回新对象new 的实现:1234567function create() &#123; let obj = &#123;&#125; let Con = [].shift.call(arguments) obj.__proto__ = Con.prototype let result = Con.apply(obj, arguments) return result instanceof Object ? result : obj&#125; 对实现的分析: 创建一个空对象 获取构造函数 设置空对象的原型 绑定 this 并执行构造函数 确保返回值为对象 对于对象来说，实际上都是通过 new 产生的，无论是 function Foo() 还是 let a = { b : 1 } 。 对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为使用 new Object() 的方式创建对象需要通过作用域链一层层找到 Object，但是使用字面量的方式就没这个问题。 12345function Foo() &#123;&#125;// function 就是个语法糖// 内部等同于 new Function()let a = &#123; b: 1 &#125;// 这个字面量内部也是使用了 new Object() 参考文献：《JavaScript高级程序设计》、掘金小册《前端面试之道》]]></content>
      <categories>
        <category>JavaScript学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue的组件通信方式]]></title>
    <url>%2Fvue-component.html</url>
    <content type="text"><![CDATA[父子组件通信父组件向子组件传递数据这种情况最常见的方式是通过标签属性向子组件传递数据，子组件用props属性接收数据。例如父组件模板如下：12345678&lt;template&gt; &lt;div&gt; &lt;detail-banner :sightName="sightName" :bannerImg="bannerImg" :bannerImgs="galleryImgs"&gt;&lt;/detail-banner&gt; &lt;detail-header&gt;&lt;/detail-header&gt; &lt;detail-list :list="list"&gt;&lt;/detail-list&gt; &lt;div class="content"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 父组件的数据以标签属性形式传递三项数据给子组件DetailBanner，子组件接收方式如下：12345678export default &#123; name: 'DetailBanner', props: &#123; sightName: String, bannerImg: String, bannerImgs: Array &#125;&#125; 注意子组件props接收时可以说明该数据的类型，以达到验证的目的 子组件向父组件传递数据子组件向父组件传递数据常见的方式是子组件通过emit发送事件传递数据给父组件12345&lt;template&gt; &lt;ul class="list"&gt; &lt;li class="item" @click="handleLetterClick"&gt;A&lt;/li&gt; &lt;/ul&gt;&lt;/template&gt; 12345methods: &#123; handleLetterClick (e) &#123; this.$emit('change', e.target.innerText) &#125;&#125; 以上代码中，子组件CityAlphabet通过emit向父组件发送change事件，将标签内的文字传递给父组件12345&lt;template&gt; &lt;div&gt; &lt;city-alphabet @change="handleLetterChange"&gt;&lt;/city-alphabet&gt; &lt;/div&gt;&lt;/template&gt; 父组件在子组件相应的标签上添加事件change来接收子组件发送的数据,并在handleLetterChange方法中对数据进行处理 兄弟组件通信兄弟组件即为同一父组件下的同级子组件，这类组件通信可以通过像父子组件通信方式来实现，先子传父，再父传子，这里不再赘述。还有一种方法是通过查找父组件的子组件实现，也就是this.$parent.$children，在$children中可以通过组件名查询到组件实例，然后进行通信 跨多层次组件通信对于这种情况可以使用provide/inject假设有父组件A，一个跨多层级的子组件B12345678910111213// 父组件export default &#123; provide: &#123; data: 1 &#125;&#125;// 子组件export default &#123; inject: ['data'] mounted: &#123; console.log(this.data) // 1 &#125;&#125; 然而这种方式官方文档不推荐直接使用到业务代码中 任意组件任意组件的通信可以通过 Event Bus 来实现，通过在 Vue 的原型上添加一个 bus 属性，并通过该属性监听组件上值的改变。如以下代码实现兄弟组件的传值123456789101112131415161718192021222324252627282930313233&lt;div id='app'&gt; &lt;child content='A'&gt;&lt;/child&gt; &lt;child content='B'&gt;&lt;/child&gt;&lt;/div&gt;&lt;script&gt; // 在Vue原型上添加bus属性 Vue.prototype.bus = new Vue() Vue.component('child', &#123; data: funtion() &#123; return &#123; selfContent: this.content &#125; &#125;, props: &#123; content: String &#125;, template: '&lt;div @click="handleClick"&gt;&#123;&#123;selfContent&#125;&#125;&lt;/div&gt;' methods: &#123; handleClick: function() &#123; // 向外触发change事件 this.bus.$emit('change', this.selfContent) &#125; &#125;, mounted: function() &#123; let _this = this; // 监听change事件 this.bus.$on('change', function(msg) &#123; _this.selfContent = msg &#125;) &#125; &#125;)&lt;/script&gt; 当然除此之外我们可以通过 Vuex 来实现，Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式，这里就不详细介绍。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-router相关知识]]></title>
    <url>%2Fvue-router.html</url>
    <content type="text"><![CDATA[解读 router/index.js12345678910111213import Vue from 'vue' //引入Vueimport Router from 'vue-router' //引入vue-routerimport Hello from '@/components/Hello' //引入根目录下的Hello.vue组件Vue.use(Router) //Vue全局使用Routerexport default new Router(&#123; routes: [ //配置路由，这里是个数组 &#123; //每一个链接都是一个对象 path: '/', //链接路径 name: 'Hello', //路由名称， component: Hello //对应的组件模板 &#125; ]&#125;) vue-router传参一. 用name传参1.在src/router/index.js例配置name属性1234567routes: [&#123; path: '/', name: 'Hello', component: Hello&#125;] 2.模板里(src/App.vue)用$route.name的形式接收，比如直接在模板中显示：1&lt;p&gt;&#123;&#123; $route.name&#125;&#125;&lt;/p&gt; 二. 用标签中的to传参1&lt;router-link :to=&quot;&#123;name:xxx,params:&#123;key:value&#125;&#125;&quot;&gt;valueString&lt;/router-link&gt; 这里的to前边是带冒号的，然后后边跟的是一个对象形式的字符串. name:就是在路由配置文件中起的name值。 params:就是我们要传的参数，它也是对象形式，在对象里可以传递多个值。 vue-router 利用url传递参数:冒号的形式传递参数 我们可以在理由配置文件里以:冒号的形式传递参数，这就是对参数的绑定。 1234&#123; path:'/params/:newsId/:newsTitle', component:Params&#125; 在src/components目录下建立我们params.vue组件，也可以说是页面。我们在页面里输出了url传递的的新闻ID和新闻标题。 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; msg &#125;&#125;&lt;/h2&gt; &lt;p&gt;新闻ID：&#123;&#123; $route.params.newsId&#125;&#125;&lt;/p&gt; &lt;p&gt;新闻标题：&#123;&#123; $route.params.newsTitle&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'params', data () &#123; return &#123; msg: 'params page' &#125; &#125;&#125;&lt;/script&gt; 在App.vue文件里加入我们的标签。这时候我们可以直接利用url传值了。 1&lt;router-link to="/params/198/jspang website is very good"&gt;params&lt;/router-link&gt; redirect和aliasredirect基本重定向我们只要在路由配置文件中（/src/router/index.js）把原来的component换成redirect参数就可以了。我们来看一个简单的配置。1234567891011121314export default new Router(&#123; routes: [ &#123; path: '/', component: Hello &#125;,&#123; path:'/params/:newsId(\\d+)/:newsTitle', component:Params &#125;,&#123; path:'/goback', redirect:'/' &#125; ]&#125;) alias别名使用 首先我们在路由配置文件里（/src/router/index.js），给上节课的Home路径起一个别名，hdy。 12345&#123; path: '/hi1', component: Hi1, alias:'/hdy' &#125; 配置我们的，起过别名之后，可以直接使用标签里的to属性，进行重新定向。 1&lt;router-link &lt; to="/hdy"&gt;jspang&lt;/router-link&gt; redirect和alias的区别 redirect：仔细观察URL，redirect是直接改变了url的值，把url变成了真实的path路径。 URL路径没有别改变，这种情况更友好，让用户知道自己访问的路径，只是改变了&lt;router-view&gt;中的内容。 路由的过渡动画&lt;transition&gt;标签想让路由有过渡动画，需要在&lt;router-view&gt;标签的外部添加&lt;transition&gt;标签，标签还需要一个name属性。123&lt;transition name="fade"&gt; &lt;router-view &gt;&lt;/router-view&gt;&lt;/transition&gt; css过渡类名:组件过渡过程中，会有四个CSS类名进行切换，这四个类名与transition的name属性有关，比如name=”fade”,会有如下四个CSS类名： fade-enter:进入过渡的开始状态，元素被插入时生效，只应用一帧后立刻删除。 fade-enter-active:进入过渡的结束状态，元素被插入时就生效，在过渡过程完成后移除。 fade-leave:离开过渡的开始状态，元素被删除时触发，只应用一帧后立刻删除。 fade-leave-active:离开过渡的结束状态，元素被删除时生效，离开过渡完成后被删除。 过渡模式mode： in-out:新元素先进入过渡，完成之后当前元素过渡离开。(默认) out-in:当前元素先进行过渡离开，离开完成后新元素过渡进入。 路由属性mode history：在此模式下url没有#号，较好看 hash：默认模式，url带有模式hash值 404页面用户会经常输错页面，当用户输错页面时，我们希望给他一个友好的提示，为此美工都会设计一个漂亮的页面，这个页面就是我们常说的404页面。 路由配置1234&#123; path:'*', component:Error&#125; 路由中的钩子路由配置文件中的钩子函数 我们可以直接在路由配置文件（/src/router/index.js）中写钩子函数。但是在路由文件中我们只能写一个beforeEnter,就是在进入此路由配置时。123456789&#123; path:'/params/:newsId(\\d+)/:newsTitle', component:Params, beforeEnter:(to,from,next)=&gt;&#123; console.log('我进入了params模板'); console.log(to); console.log(from); next();&#125;, 三个参数： to：路由将要跳转的路径信息，信息是包含在对象里边的。 from：路径跳转前的路径信息，也是一个对象的形式。 next：路由的控制参数，常用的有next(true)和next(false)。 写在模板中的钩子函数在模板中就可以有两个钩子函数可以使用： beforeRouteEnter：在路由进入前的钩子函数。 beforeRouteLeave：在路由离开前的钩子函数。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue的基础知识点]]></title>
    <url>%2Fvue-basis.html</url>
    <content type="text"><![CDATA[一、全局APIVue.directive自定义指令 自定义指令传递的三个参数 el: 指令所绑定的元素，可以用来直接操作DOM。 binding: 一个对象，包含指令的很多信息。 vnode: Vue编译生成的虚拟节点。 自定义指令的生命周期自定义指令有五个生命周期（也叫钩子函数），分别是bind, inserted, update, componentUpdated, unbind bind:只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个绑定时执行一次的初始化动作。 inserted:被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于document中）。 update:被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。 componentUpdated:被绑定元素所在模板完成一次更新周期时调用。 unbind:只调用一次，指令与元素解绑时调用。 Vue-setVue.set 的作用就是在构造器外部操作构造器内部的数据、属性或者方法。 为什么要有Vue.set的存在? 由于Javascript的限制，Vue不能自动检测以下变动的数组。 当你利用索引直接设置一个项时，vue不会为我们自动更新。 当你修改数组的长度时，vue不会为我们自动更新。 Vue的生命周期 钩子函数123456789101112131415161718192021222324252627282930beforeCreate:function()&#123; console.log('1-beforeCreate 初始化之后');&#125;,created:function()&#123; console.log('2-created 创建完成');&#125;,beforeMount:function()&#123; console.log('3-beforeMount 挂载之前');&#125;,mounted:function()&#123; console.log('4-mounted 被创建');&#125;,beforeUpdate:function()&#123; console.log('5-beforeUpdate 数据更新前');&#125;,updated:function()&#123; console.log('6-updated 被更新后');&#125;,activated:function()&#123; console.log('7-activated');&#125;,deactivated:function()&#123; console.log('8-deactivated');&#125;,beforeDestroy:function()&#123; console.log('9-beforeDestroy 销毁之前');&#125;,destroyed:function()&#123; console.log('10-destroyed 销毁之后')&#125; Template模板 直接写在选项里，适合较短的html代码 写在template标签里，适合长的html代码 写在script标签里，适合外部引入模板文件 组件Component组件就是自定义的标签 全局化注册组件全局化就是在构造器的外部用Vue.component来注册 局部注册组件局部注册组件局部注册组件和全局注册组件是相对应的，局部注册的组件只能在组件注册的作用域里进行使用，其他作用域使用无效。 组件和指令的区别组件注册的是一个标签，而指令注册的是已有标签里的一个属性。在实际开发中我们还是用组件比较多，指令用的比较少。因为指令看起来封装的没那么好，这只是个人观点。 Component 父子组件关系在实际开发中我们经常会遇到在一个自定义组件中要使用其他自定义组件，这就需要一个父子组件关系。 Component 标签标签是Vue框架自定义的标签，它的用途就是可以动态绑定我们的组件，根据数据的不同更换不同的组件。 二、实例实例方法 $mount 方法用来挂在扩展 $destroy() 卸载方法 $forceUpdate() 更新方法 $nextTick() 数据修改方法当Vue构造器里的data值被修改完成后会调用这个方法 实例事件 $on 在构造器外部添加事件$on接收两个参数，第一个参数是调用时的事件名称，第二个参数是一个匿名方法。 1234app.$on('reduce',function()&#123; console.log('执行了reduce()'); this.num--;&#125;); $once 执行一次的事件 $off 关闭事件 1234//关闭事件function off()&#123; app.$off('reduce');&#125; slotslot是标签的内容扩展，也就是说你用slot就可以在自定义组件时传递给组件内容，组件接收内容并输出。 三、选项相关computed Option 计算选项computed 的作用主要是对原数据进行改造输出。改造输出：包括格式的编辑，大小写转换，顺序重排，添加符号……。 Methods Option 方法选项 methods中参数的传递使用方法和正常的javascript传递参数的方法一样，分为两部： 在methods的方法中进行声明，比如我们给add方法加上一个num参数，就要写出add:function(num){} 调用方法时直接传递，比如我们要传递2这个参数，我们在button上就直接可以写。@click=”add(2)”&gt;&lt;/button&gt; methods中的$event参数传递的$event参数都是关于你点击鼠标的一些事件和属性。 native 给组件绑定构造器里的原生事件在实际开发中经常需要把某个按钮封装成组件，然后反复使用，如何让组件调用构造器里的方法，而不是组件里的方法。就需要用到我们的.native修饰器了&lt;p&gt;&lt;btn @click.native=&quot;add(3)&quot;&gt;&lt;/btn&gt;&lt;/p&gt; 作用域外部调用构造器里的方法&lt;button onclick=&quot;app.add(4)&quot; &gt;&lt;/button&gt;不常用，不提倡用 Mixins 混入选项操作 Mixins一般有两种用途： 在你已经写好了构造器后，需要增加方法或者临时的活动时使用的方法，这时用混入会减少源代码的污染。 很多地方都会用到的公用方法，用混入的方法可以减少代码量，实现代码重用。 mixins的调用顺序全局-&gt;混入-&gt;构造器里PS：当混入方法和构造器的方法重名时，混入的方法无法展现，也就是不起作用。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6解构赋值与函数相关知识点]]></title>
    <url>%2Fes6-function.html</url>
    <content type="text"><![CDATA[一、箭头函数注意点 箭头函数有几个使用注意点： （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 this对象的指向一般是可变的，但是在箭头函数中，它是固定的。12345678910function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// id: 42 上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。 箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。1234567891011121314151617function Timer() &#123; this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() =&gt; this.s1++, 1000); // 普通函数 setInterval(function () &#123; this.s2++; &#125;, 1000);&#125;var timer = new Timer();setTimeout(() =&gt; console.log('s1: ', timer.s1), 3100);setTimeout(() =&gt; console.log('s2: ', timer.s2), 3100);// s1: 3// s2: 0 上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，timer.s1被更新了 3 次，而timer.s2一次都没更新。 箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面。123456789101112var handler = &#123; id: '123456', init: function() &#123; document.addEventListener('click', event =&gt; this.doSomething(event.type), false); &#125;, doSomething: function(type) &#123; console.log('Handling ' + type + ' for ' + this.id); &#125;&#125;; 上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。 所以，箭头函数转成 ES5 的代码如下。123456789101112131415// ES6function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;// ES5function foo() &#123; var _this = this; setTimeout(function () &#123; console.log('id:', _this.id); &#125;, 100);&#125; 上面代码中，可以看出箭头函数里面根本没有自己的this，而是引用外层的this。 请问下面的代码之中有几个this？123456789101112131415function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log('id:', this.id); &#125;; &#125;; &#125;;&#125;var f = foo.call(&#123;id: 1&#125;);var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1var t2 = f().call(&#123;id: 3&#125;)(); // id: 1var t3 = f()().call(&#123;id: 4&#125;); // id: 1 上面代码之中，只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。 除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。12345678function foo() &#123; setTimeout(() =&gt; &#123; console.log('args:', arguments); &#125;, 100);&#125;foo(2, 4, 6, 8)// args: [2, 4, 6, 8] 上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。 另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。123456(function() &#123; return [ (() =&gt; this.x).bind(&#123; x: 'inner' &#125;)() ];&#125;).call(&#123; x: 'outer' &#125;);// ['outer'] 上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。 长期以来，JavaScript 语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。箭头函数”绑定”this，很大程度上解决了这个困扰。 二、双冒号运算符箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以现在有一个提案，提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。 函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。123456789101112foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments);const hasOwnProperty = Object.prototype.hasOwnProperty;function hasOwn(obj, key) &#123; return obj::hasOwnProperty(key);&#125; 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。1234567var method = obj::obj.foo;// 等同于var method = ::obj.foo;let log = ::console.log;// 等同于var log = console.log.bind(console); 如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法。123456import &#123; map, takeWhile, forEach &#125; from "iterlib";getPlayers()::map(x =&gt; x.character())::takeWhile(x =&gt; x.strength &gt; 100)::forEach(x =&gt; console.log(x)); 三、解构赋值解构赋值默认值与函数参数默认值123456789// 写法一function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;// 写法二function m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125; 写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。123456789101112131415161718// 函数没有参数的情况m1() // [0, 0]m2() // [0, 0]// x 和 y 都有值的情况m1(&#123;x: 3, y: 8&#125;) // [3, 8]m2(&#123;x: 3, y: 8&#125;) // [3, 8]// x 有值，y 无值的情况m1(&#123;x: 3&#125;) // [3, 0]m2(&#123;x: 3&#125;) // [3, undefined]// x 和 y 都无值的情况m1(&#123;&#125;) // [0, 0];m2(&#123;&#125;) // [undefined, undefined]m1(&#123;z: 3&#125;) // [0, 0]m2(&#123;z: 3&#125;) // [undefined, undefined] 函数的length属性指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。123(function (a) &#123;&#125;).length // 1(function (a = 5) &#123;&#125;).length // 0(function (a, b, c = 5) &#123;&#125;).length // 2 上面代码中，length属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3 个参数，其中有一个参数c指定了默认值，因此length属性等于3减去1，最后得到2。 这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入length属性。1(function(...args) &#123;&#125;).length // 0 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。12(function (a = 0, b, c) &#123;&#125;).length // 0(function (a, b = 1, c) &#123;&#125;).length // 1 本文参考自阮一峰大神的《ES6标准入门》原文链接：http://es6.ruanyifeng.com/]]></content>
      <categories>
        <category>JavaScript学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中的数组相关知识点]]></title>
    <url>%2Fjs-array.html</url>
    <content type="text"><![CDATA[1.数组的每一项可以用来保存任何类型的数据 2.可以通过length属性在数组末尾移除项或向数组添加新项123var colors = ["red", "blue", "green"]; //creates an array with three stringscolors.length = 2;alert(colors[2]); //undefined 123var colors = ["red", "blue", "green"]; //creates an array with three stringscolors.length = 4;alert(colors[3]); //undefined 3.alert()方法要接收字符串参数时会在后台调用toString()方法，都是创建一个数组值的以逗号分隔的字符串 4.join()方法可以使用不同的分隔符来构建字符串123var colors = ["red", "green", "blue"];alert(colors.join(",")); //red,green,bluealert(colors.join("||")); //red||green||blue 5.栈和队列 push()返回添加后的数组长度，而pop()返回移除的项,二者实现类似栈行为 shift()移除数组中第一个项并返回该项，数组长度减一，和push()结合模拟队列 unshift()在数组前端添加任意个项并返回新数组长度，与pop()结合从相反方向模拟队列 6.重排序方法 reverse()反转数组项顺序 sort()调用每个数组项的toString()，比较得到的字符串确定排序，即是数组项是数值 7.操作方法concat()基于当前数组中的所有项创建一个新数组1234var colors = ["red", "green", "blue"];var colors2 = colors.concat("yellow", ["black", "brown"]);alert(colors); //red,green,blue alert(colors2); //red,green,blue,yellow,black,brown slice()基于当前数组的一或多项创建一个新数组 12345var colors = ["red", "green", "blue", "yellow", "purple"];var colors2 = colors.slice(1);var colors3 = colors.slice(1,4);alert(colors2); //green,blue,yellow,purplealert(colors3); //green,blue,yellow splice() 删除：可以删除任意数量的项，参数为要删除的第一项位置和要删除的项数 1234var colors = ["red", "green", "blue"];var removed = colors.splice(0,1); //remove the first itemalert(colors); //green,bluealert(removed); //red - one item array 插入：向指定位置插入任意数量的项，需提供3个参数：起始位置、0（要删除的项数）和要插入的项。例如，splice(2,0,”red”,”green”)会从当前数组的位置2开始插入字符串red和green 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项。3个参数：起始位置、要删除的项数和要插入的任意数量的项。例如，splice(2,1,”red”,”green”)会删除当前数组位置2的项，然后再从位置2开始插入red和green 8.位置方法indexOf()和lastIndexOf()都有2个参数：要查找的项和（可选）表示查找起点位置的索引，返回查找项的位置，没找到返回-1。indexOf()正向查找，lastIndexOf()反向 9.迭代方法2个参数：要在每一项上运行的函数和（可选）运行该函数的作用域对象；其中的函数有3个参数：数组项的值、该项在数组中的位置和数组对象本身 every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组 forEach()：对数组中的每一项运行给定函数，无返回值 map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组 some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true 10.归并方法2个参数：一个在每一项上调用的函数和（可选）作为归并基础的初始值；其中的函数有4个参数：前一个值、当前值、项的索引和数组对象，函数的返回值作为第一参数传给下一项，第一个参数时数组的第一项，第二个参数时数组的第二项 reduce()从数组第一项开始逐个遍历 reduceRight()从数组最后一项开始，反向遍历]]></content>
      <categories>
        <category>JavaScript学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2FgitCommand.html</url>
    <content type="text"><![CDATA[一、新建代码库123git init 在当前目录新建一个Git代码库 git init [project-name] 新建一个目录，将其初始化为Git代码库 git clone [url] 下载一个项目和它的整个代码历史 二、配置1234git config --list 显示当前的Git配置git config -e [--global] 编辑Git配置文件git config [--global] user.name "[name]" git config [--global] user.email "[email address]" 设置提交代码时的用户信息 三、添加/删除/修改文件123456789git status 查看状态git diff 查看变更内容git add [file1] [file2] ... 添加指定文件到暂存区git add [dir] 添加指定目录到暂存区，包括子目录git add . 添加当前目录的所有文件到暂存区git add -p 添加每个变化前，都会要求确认 对于同一个文件的多处变化，可以实现分次提交 git rm [file1] [file2] ...删除工作区文件，并且将这次删除放入暂存区git rm --cached [file] 停止追踪指定文件，但该文件会保留在工作区git mv [file-original] [file-renamed] 改名文件，并且将这个改名放入暂存区 四、代码提交123456git commit -m [message] 提交暂存区到仓库区git commit [file1] [file2] ... -m [message]提交暂存区的指定文件到仓库区git commit -a 提交工作区自上次commit之后的变化，直接到仓库区git commit -v提交时显示所有diff信息git commit --amend -m [message] 使用一次新的commit，替代上一次提交 如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend [file1] [file2] ... 重做上一次commit，并包括指定文件的新变化 五、分支123456789101112131415git branch 显示所有本地分支git branch -r 列出所有远程分支git branch -a 列出所有本地分支和远程分支git branch [branch-name] 新建一个分支，但依然停留在当前分支git branch --track [branch] [remote-branch] 新建一个分支，与指定的远程分支建立追踪关系git branch -d [branch-name] 删除分支git push origin --detele [branch-name] git branch -dr [remote/branch] 删除远程分支git checkout -b [branch] 新建一个分支，并切换到该分支git checkout [branch-name] 切换到指定分支，并更新工作区git checkout - 切换到上一个分支git branch --set -upstream [branch] [remote-branch] 建立追踪关系，在现有分支与指定的远程分支之间git merge [branch] 合并指定分支到当前分支git rebase &lt;branch&gt; 衍合指定分支到当前分支git cherry-pick [commit] 选择一个commit，合并到当前分支 六、标签12345678git tag 列出所有本地标签git tag &lt;tag-name&gt; 基于最新的提交创建标签git tag -d &lt;tag-name&gt; 删除指定标签git push origin :refs/tags/[tag-name] 删除远程标签git show [tag] 查看标签信息git push [remote] [tag] 提交指定标签git push [remote] --tags 提交所有标签git checkout -b [branch] [tag] 新建一个分支，指向某个标签 七、查看信息123456789101112131415161718192021git status 显示有变更的文件git log 显示当前分支的版本历史git log --stat 显示提交历史，以及每次提交发生变更的文件git log -S [keyword] 根据关键词搜索提交历史git log [tag] HEAD --pretty=format:%s 显示某个提交之后的所有变动git log [tag] HEAD --grep featuregit log --follow [file]git whatchanged [file] 显示某个文件的版本历史，包括文件改名git log -p [file] 显示指定文件相关的每一次diffgit log -5 --pretty --online 显示过去5次提交git shortlog -sn 显示所有提交过的用户，按提交次数排序git blame [file] 显示指定文件是何人何时修改信息git diff 显示暂存区与工作区的差异git diff --cached [file] 显示暂存区和上一个提交的差异git diff HEAD 显示工作区与当前分支最新调教之间的差异git diff [first-branch]...[second-branch] 显示两次提交之间的差异git diff --short stat "@&#123;0 day ago&#125;" 显示今天你写了多少行代码git show [commit] 显示某次提交的元数据和内容变化git show --name-only [commit] 显示某次提交发生变化的文件gitshow [commit]:[filename] 显示某次提交时，某个文件的内容git reflog 显示当前分支的最近几次提交 八、远程操作12345678910git fetch [remote] 下载远程仓库的所有变动git pull [remote] [branch] 取回远程参股的变化，并与本地分支合并git remote -v 显示所有远程仓库git remote show [remote] 显示某个远程仓库的信息git remote add [shortname] [url] 增加一个新的远程仓库git push [remote] [branch] 上传本地指定分支到远程仓库git push [remote] --force 强制推送当前分支到远程仓库git push [remote] --all 推动所有分支到远程仓库git push &lt;remote&gt; 删除远程分支或标签git push --tags 上传所有标签 九、撤销123456789101112131415git reset --hard HEAD 撤销工作目录中所有未提交文件的修改内容git checkout HEAD &lt;file&gt; 撤销指定的未提交文件的修改内容git revert &lt;commit&gt; 撤销指定的提交git log --before="1 days" 退回到之前1天的版本git checkout [file] 恢复暂存区的指定文件到工作区git checkout [commit] [file] 恢复某个提交的指定文件到暂存区和工作区git checkout . 恢复暂存区的所有文件到工作区git reset [file] 重置暂存区的指定文件，遇上一次提交保持一致，但工作区不变git reset --hard 重置暂存区与工作区，与上次提交保持一致git reset [commit] 重置当前分支的指针为指定提交，同时重置暂存区，但工作区不变git reset --hard [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --keep [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变git revert [commit] 新建一个commit，用来撤销指定commit，后者的所有变化豆浆杯前者抵消，并且应用到当前分支git stashgit stash pop 暂时将未提交的变化移除，稍后再移入]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
